#!/usr/bin/env ts-node

const fs = require('fs');
const path = require('path');

interface CliOptions {
  project?: string;
  help?: boolean;
}

interface SidebarItem {
  type: 'doc' | 'category' | 'link';
  id?: string;
  label?: string;
  items?: SidebarItem[];
  href?: string;
}


class GitBookMigrator {
  private gitbookDir = './gitbook-docs';
  private docsDir = './docs';
  private staticDir = './static';

  async migrateAllProjects(specificProject?: string): Promise<void> {
    console.log('üöÄ Starting GitBook to Docusaurus migration...');

    const allProjects = fs.readdirSync(this.gitbookDir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => dirent.name);

    let projects: string[];

    if (specificProject) {
      if (!allProjects.includes(specificProject)) {
        throw new Error(`‚ùå Project "${specificProject}" not found. Available projects: ${allProjects.join(', ')}`);
      }
      projects = [specificProject];
      console.log(`üìÇ Migrating specific project: ${specificProject}`);
    } else {
      projects = allProjects;
      console.log(`üìÇ Found projects: ${projects.join(', ')}`);
    }

    for (const project of projects) {
      console.log(`\nüîÑ Processing project: ${project}`);
      await this.processProject(project);
    }

    console.log('\n‚úÖ Migration completed successfully!');
  }

  private async processProject(projectName: string): Promise<void> {
    const projectPath = path.join(this.gitbookDir, projectName);
    const targetDocsPath = path.join(this.docsDir, projectName);
    const targetStaticPath = path.join(this.staticDir, projectName, 'imgs');

    // Create target directories
    this.ensureDirectoryExists(targetDocsPath);
    this.ensureDirectoryExists(targetStaticPath);

    console.log(`  üìù Converting README.md to Introduction.md`);
    await this.convertReadmeToIntroduction(projectPath, targetDocsPath);

    console.log(`  üóÇÔ∏è  Generating sidebars.js from SUMMARY.md`);
    await this.generateSidebarsFromSummary(projectPath, targetDocsPath);

    console.log(`  üì∏ Copying assets to static folder`);
    await this.copyAssets(projectPath, targetStaticPath);

    console.log(`  üìÑ Copying and updating documentation files`);
    await this.copyAndUpdateDocs(projectPath, targetDocsPath, projectName);

    console.log(`  ‚úÖ Project ${projectName} migration completed`);
  }

  private async convertReadmeToIntroduction(projectPath: string, targetDocsPath: string): Promise<void> {
    const readmePath = path.join(projectPath, 'README.md');
    const introductionPath = path.join(targetDocsPath, 'Introduction.md');

    if (!fs.existsSync(readmePath)) {
      console.log(`    ‚ö†Ô∏è  README.md not found in ${projectPath}`);
      return;
    }

    let content = fs.readFileSync(readmePath, 'utf-8');

    // Format the document using the comprehensive formatter
    content = this.formatDocFile(content, projectPath.split('/').pop()!);

    fs.writeFileSync(introductionPath, content, 'utf-8');
  }

  private async generateSidebarsFromSummary(projectPath: string, targetDocsPath: string): Promise<void> {
    const summaryPath = path.join(projectPath, 'SUMMARY.md');
    const sidebarPath = path.join(targetDocsPath, 'sidebars.js');

    if (!fs.existsSync(summaryPath)) {
      console.log(`    ‚ö†Ô∏è  SUMMARY.md not found in ${projectPath}`);
      return;
    }

    const summaryContent = fs.readFileSync(summaryPath, 'utf-8');
    const sidebarItems = this.parseSummaryToSidebar(summaryContent);

    const sidebarConfig = `module.exports = {
  myAutogeneratedSidebar: [
    {
      type: "doc",
      id: "Introduction",
      label: "üìñ Introduction",
    },
${this.generateSidebarItemsString(sidebarItems, '    ')}
  ],
};
`;

    fs.writeFileSync(sidebarPath, sidebarConfig, 'utf-8');
  }

  private parseSummaryToSidebar(summaryContent: string): SidebarItem[] {
    const lines = summaryContent.split('\n');
    const items: SidebarItem[] = [];
    let currentCategory: SidebarItem | null = null;

    for (const line of lines) {
      const trimmedLine = line.trim();

      // Skip empty lines and table of contents header
      if (!trimmedLine || trimmedLine.startsWith('#')) continue;

      // Check if this is a section header (##)
      if (trimmedLine.startsWith('##')) {
        const categoryLabel = trimmedLine.replace('##', '').trim();
        currentCategory = {
          type: 'category',
          label: categoryLabel,
          items: []
        };
        items.push(currentCategory);
        continue;
      }

      // Check if this is a doc item (* [Title](path))
      const docMatch = trimmedLine.match(/^\*\s*\[([^\]]+)\]\(([^)]+)\)$/);
      if (docMatch) {
        const [, title, filePath] = docMatch;

        // Skip README.md as it's converted to StartHere.md
        if (filePath === 'README.md') continue;

        const docId = this.filePathToDocId(filePath);
        const docItem: SidebarItem = {
          type: 'doc',
          id: docId,
          label: title
        };

        if (currentCategory && currentCategory.items) {
          currentCategory.items.push(docItem);
        } else {
          items.push(docItem);
        }
      }
    }

    return items;
  }

  private escapeQuotesInLabel(label: string): string {
    // Escape double quotes in labels to prevent syntax errors
    return label.replace(/"/g, '\\"');
  }

  private generateSidebarItemsString(items: SidebarItem[], indent: string): string {
    return items.map(item => {
      if (item.type === 'category') {
        const nestedItems = item.items ? this.generateSidebarItemsString(item.items, indent + '  ') : '';
        const escapedLabel = this.escapeQuotesInLabel(item.label || '');
        return `${indent}{
${indent}  type: "category",
${indent}  label: "${escapedLabel}",
${indent}  items: [
${nestedItems}
${indent}  ],
${indent}},`;
      } else if (item.type === 'doc') {
        const escapedLabel = this.escapeQuotesInLabel(item.label || '');
        return `${indent}{ type: "doc", id: "${item.id}", label: "${escapedLabel}" },`;
      }
      return '';
    }).join('\n');
  }

  private async copyAssets(projectPath: string, targetStaticPath: string): Promise<void> {
    const assetsPath = path.join(projectPath, '.gitbook', 'assets');

    if (!fs.existsSync(assetsPath)) {
      console.log(`    ‚ö†Ô∏è  Assets folder not found in ${projectPath}`);
      return;
    }

    this.copyDirectory(assetsPath, targetStaticPath);
  }

  private async copyAndUpdateDocs(projectPath: string, targetDocsPath: string, projectName: string): Promise<void> {
    const items = fs.readdirSync(projectPath, { withFileTypes: true });

    for (const item of items) {
      // Skip special GitBook files and directories
      if (['README.md', 'SUMMARY.md', '.gitbook', '.git'].includes(item.name)) {
        continue;
      }

      const sourcePath = path.join(projectPath, item.name);
      const targetPath = path.join(targetDocsPath, item.name);

      if (item.isDirectory()) {
        this.ensureDirectoryExists(targetPath);
        this.copyDocumentationDirectory(sourcePath, targetPath, projectName);
      } else if (item.name.endsWith('.md')) {
        this.copyAndUpdateMarkdownFile(sourcePath, targetPath, projectName);
      }
    }
  }

  private copyDocumentationDirectory(sourceDir: string, targetDir: string, projectName: string): void {
    const items = fs.readdirSync(sourceDir, { withFileTypes: true });

    for (const item of items) {
      const sourcePath = path.join(sourceDir, item.name);
      const targetPath = path.join(targetDir, item.name);

      if (item.isDirectory()) {
        this.ensureDirectoryExists(targetPath);
        this.copyDocumentationDirectory(sourcePath, targetPath, projectName);
      } else if (item.name.endsWith('.md')) {
        this.copyAndUpdateMarkdownFile(sourcePath, targetPath, projectName);
      }
    }
  }

  private copyAndUpdateMarkdownFile(sourcePath: string, targetPath: string, projectName: string): void {
    let content = fs.readFileSync(sourcePath, 'utf-8');

    // Format the document using the comprehensive formatter
    content = this.formatDocFile(content, projectName);

    fs.writeFileSync(targetPath, content, 'utf-8');
  }

  private removeAllFrontmatter(content: string): string {
    // Remove any frontmatter (GitBook or existing Docusaurus)
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---\n\n?/);
    if (frontmatterMatch) {
      return content.substring(frontmatterMatch[0].length);
    }
    return content;
  }

  private convertGitBookTables(content: string): string {
    // Convert GitBook table syntax to standard markdown
    // This is a simplified conversion - may need enhancement for complex tables
    content = content.replace(/<table[\s\S]*?<\/table>/gi, (match) => {
      // For now, just remove GitBook specific table attributes and convert to basic markdown
      // This would need more sophisticated parsing for production use
      return '<!-- Table converted from GitBook format -->\n' + match;
    });

    return content;
  }

  private convertGitBookHints(content: string): string {
    // Convert GitBook hint blocks to custom Hint component
    // Pattern: {% hint style="info" %} ... {% endhint %}
    const hintPattern = /{% hint style="(info|warning|danger|success)" %}\n([\s\S]*?)\n{% endhint %}/g;

    return content.replace(hintPattern, (match, style, hintContent) => {
      // Clean up the hint content by trimming whitespace
      const cleanContent = hintContent.trim();

      // Convert to JSX Hint component with import
      return `<Hint style="${style}">
${cleanContent}
</Hint>`;
    });
  }

  private addHintImport(content: string): string {
    // Check if the content contains any Hint components
    if (content.includes('<Hint')) {
      // Add the import statement at the top of the file
      const importStatement = "import Hint from '@site/src/components/Hint';\n\n";
      return importStatement + content;
    }
    return content;
  }

  private fixUnclosedImgTags(content: string): string {
    // Fix unclosed img tags by converting <img ...> to <img ... />
    // This handles both single-line and multi-line img tags
    return content.replace(/<img([^>]*?)(?<!\/)>/g, '<img$1 />');
  }

  private convertGitBookEmbeds(content: string): string {
    // Convert GitBook embed blocks to iframe elements
    // Pattern: {% embed url="https://www.youtube.com/watch?v=VIDEO_ID" %}
    const embedPattern = /{% embed url="([^"]+)" %}/g;

    return content.replace(embedPattern, (match, url) => {
      // Check if it's a YouTube URL and convert to embed format
      const youtubeMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]+)/);

      if (youtubeMatch) {
        const videoId = youtubeMatch[1];
        const embedUrl = `https://www.youtube.com/embed/${videoId}`;

        return `<iframe height="400" width="100%" src="${embedUrl}" title="Video" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen></iframe>`;
      }

      // For other URLs, create a generic iframe
      return `<iframe height="400" width="100%" src="${url}" title="Embedded Content" frameBorder="0" allowFullScreen></iframe>`;
    });
  }

  private formatDocFile(content: string, projectName: string): string {
    // Remove all existing frontmatter
    content = this.removeAllFrontmatter(content);

    // Convert GitBook table syntax
    content = this.convertGitBookTables(content);

    // Convert GitBook hints to custom Hint components
    content = this.convertGitBookHints(content);

    // Convert GitBook embeds to iframe elements
    content = this.convertGitBookEmbeds(content);

    // Fix unclosed img tags
    content = this.fixUnclosedImgTags(content);

    // Update image paths
    content = this.updateImagePathsInContent(content, projectName);

    // Add Hint import if needed
    content = this.addHintImport(content);

    return content;
  }

  private updateImagePathsInContent(content: string, projectName: string): string {
    // Replace GitBook image paths with Docusaurus static paths
    // Pattern: ../.gitbook/assets/filename.ext -> /projectName/imgs/filename.ext
    return content.replace(/\.\.\/\.gitbook\/assets\//g, `/${projectName}/imgs/`);
  }

  private filePathToDocId(filePath: string): string {
    // Convert file path to Docusaurus doc ID
    // Remove .md extension and replace path separators with slashes
    return filePath.replace(/\.md$/, '').replace(/\\/g, '/');
  }

  private generateTitleFromFileName(fileName: string): string {
    // Convert filename to a readable title
    return fileName
      .replace(/-/g, ' ')
      .replace(/\b\w/g, l => l.toUpperCase());
  }

  private ensureDirectoryExists(dirPath: string): void {
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
  }

  private copyDirectory(sourceDir: string, targetDir: string): void {
    this.ensureDirectoryExists(targetDir);

    const items = fs.readdirSync(sourceDir, { withFileTypes: true });

    for (const item of items) {
      const sourcePath = path.join(sourceDir, item.name);
      const targetPath = path.join(targetDir, item.name);

      if (item.isDirectory()) {
        this.copyDirectory(sourcePath, targetPath);
      } else {
        fs.copyFileSync(sourcePath, targetPath);
      }
    }
  }
}

// Command line argument parsing
function parseArgs(args: string[]): CliOptions {
  const options: CliOptions = {};

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    if (arg === '--help' || arg === '-h') {
      options.help = true;
    } else if (arg === '--project' || arg === '-p') {
      if (i + 1 >= args.length) {
        throw new Error('‚ùå --project/-p option requires a project name');
      }
      options.project = args[i + 1];
      i++; // Skip the next argument as it's the project name
    }
  }

  return options;
}

function showHelp(): void {
  console.log(`
üöÄ GitBook to Docusaurus Migration Tool

Usage:
  yarn migrate-gitbook [options]

Options:
  -p, --project <name>    Migrate only the specified project
  -h, --help             Show this help message

Examples:
  yarn migrate-gitbook                    # Migrate all projects
  yarn migrate-gitbook -p boros-academy   # Migrate only boros-academy
  yarn migrate-gitbook --project pendle-academy  # Migrate only pendle-academy

Available projects will be listed if no specific project is provided.
  `);
}

// Main execution
async function main(): Promise<void> {
  const migrator = new GitBookMigrator();

  try {
    // Parse command line arguments (skip 'node' and script name)
    const args = process.argv.slice(2);
    const options = parseArgs(args);

    if (options.help) {
      showHelp();
      return;
    }

    await migrator.migrateAllProjects(options.project);
  } catch (error) {
    if (error instanceof Error) {
      console.error(error.message);
    } else {
      console.error('‚ùå Migration failed:', error);
    }
    process.exit(1);
  }
}

// Run the migration if this file is executed directly
if (require.main === module) {
  main();
}

module.exports = { GitBookMigrator };