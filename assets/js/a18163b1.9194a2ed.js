"use strict";(self.webpackChunkpendle_documentation=self.webpackChunkpendle_documentation||[]).push([[9642],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>k});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var d=r.createContext({}),l=function(e){var t=r.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(d.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,d=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=l(n),m=a,k=p["".concat(d,".").concat(m)]||p[m]||u[m]||i;return n?r.createElement(k,o(o({ref:t},c),{},{components:n})):r.createElement(k,o({ref:t},c))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s[p]="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3739:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));const i={},o="Custom Types",s={unversionedId:"Boros/Contracts/CustomTypes",id:"Boros/Contracts/CustomTypes",title:"Custom Types",description:"Boros heavily uses Solidity user-defined value types for gas optimization and type safety. These types use bit-packing to minimize storage costs and provide efficient operations on the EVM.",source:"@site/docs/Boros/Contracts/CustomTypes.md",sourceDirName:"Boros/Contracts",slug:"/Boros/Contracts/CustomTypes",permalink:"/Boros/Contracts/CustomTypes",draft:!1,tags:[],version:"current",frontMatter:{}},d={},l=[{value:"Core Trading Types",id:"core-trading-types",level:2},{value:"Trade",id:"trade",level:3},{value:"Account Types",id:"account-types",level:2},{value:"Account",id:"account",level:3},{value:"MarketAcc",id:"marketacc",level:3},{value:"Order Book Types",id:"order-book-types",level:2},{value:"OrderId",id:"orderid",level:3},{value:"Side",id:"side",level:3},{value:"TimeInForce",id:"timeinforce",level:3},{value:"OrderStatus",id:"orderstatus",level:3},{value:"Market Types",id:"market-types",level:2},{value:"TokenId",id:"tokenid",level:3},{value:"MarketId",id:"marketid",level:3},{value:"AMMId",id:"ammid",level:3},{value:"Advanced Types",id:"advanced-types",level:2},{value:"FIndex",id:"findex",level:3},{value:"VMResult",id:"vmresult",level:3}],c={toc:l},p="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"custom-types"},"Custom Types"),(0,a.kt)("p",null,"Boros heavily uses Solidity user-defined value types for gas optimization and type safety. These types use bit-packing to minimize storage costs and provide efficient operations on the EVM."),(0,a.kt)("h2",{id:"core-trading-types"},"Core Trading Types"),(0,a.kt)("h3",{id:"trade"},"Trade"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Definition"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"type Trade is uint256")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Bit Packing"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"signedSize(128) | signedCost(128)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// Creating trades\nTrade memory trade = TradeLib.from(signedSize, signedCost);\n\nSide side = trade.side();\nint128 size = trade.signedSize();\nint128 cost = trade.signedCost();\n")),(0,a.kt)("h2",{id:"account-types"},"Account Types"),(0,a.kt)("h3",{id:"account"},"Account"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Definition"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"type Account is bytes21")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Bit Packing"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"address(160) | accountId(8)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// Creating accounts\nAccount mainAcc = AccountLib.from(userAddress, 0);  // Main account\nAccount subAcc = AccountLib.from(userAddress, 1);   // Sub-account 1\nAccount ammAcc = userAddress.toAMM();               // AMM account 255\n\n// Parsing accounts\naddress root = account.root();         // Extract root address\nuint8 accountId = account.accountId(); // Extract account ID\n\n// Special account types\nbool isMain = account.isMain();       // accountId == 0\nbool isAMM = account.isAMM();         // accountId == 255\n")),(0,a.kt)("h3",{id:"marketacc"},"MarketAcc"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Definition"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"type MarketAcc is bytes26")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Bit Packing"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"address(160) | accountId(8) | tokenId(16) | marketId(24)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// Creating market accounts\nMarketAcc crossAcc = account.toCross(tokenId);                 // Cross-margin\nMarketAcc isolatedAcc = account.toIsolated(tokenId, marketId); // Isolated\n\n// Parsing market accounts\naddress root = crossAcc.root();\nAccount account = crossAcc.account();\nTokenId tokenId = crossAcc.tokenId();\nMarketId marketId = crossAcc.marketId();\n\n// Cross vs isolated margin\nbool isCross = isolatedAcc.isCross();\nMarketAcc crossAcc = isolatedAcc.toCross();\n")),(0,a.kt)("h2",{id:"order-book-types"},"Order Book Types"),(0,a.kt)("h3",{id:"orderid"},"OrderId"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Definition"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"type OrderId is uint64")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Bit Packing"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"initialized(1) | reserved(6) | side(1) | encodedTick(16) | orderIndex(40)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// Creating order IDs (done internally by order book)\nOrderId orderId = OrderIdLib.from(Side.LONG, tickIndex, orderIndex);\n\n// Parsing order IDs\nSide side = orderId.side();\nint16 tick = orderId.tickIndex();\nuint40 index = orderId.orderIndex();\n\n// Priority comparison (lower unwrapped value = higher priority)\nbool higherPriority = orderId1 < orderId2;\n")),(0,a.kt)("h3",{id:"side"},"Side"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Definition"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"enum Side { LONG, SHORT }")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"Side opposite = side.opposite();          // LONG \u2194 SHORT\nbool topDown = side.sweepTickTopDown();   // LONG: true, SHORT: false\nint16 endTick = side.endTick();          // Boundary tick values\n\n")),(0,a.kt)("h3",{id:"timeinforce"},"TimeInForce"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Definition"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"enum TimeInForce { GTC, IOC, FOK, ALO, SOFT_ALO }")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"GTC (Good Till Cancel)"),": Standard limit order that remains on the order book until fully filled or manually canceled"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"IOC (Immediate or Cancel)"),": Executes against available liquidity immediately, cancels any unfilled portion"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"FOK (Fill or Kill)"),": Must fill entire order size immediately or the transaction reverts"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"ALO (Add Liquidity Only)"),": Post-only order that adds liquidity to the book, transaction reverts if it would match existing orders"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"SOFT_ALO"),": Post-only order similar to ALO, but skips matching without reverting the transaction")),(0,a.kt)("h3",{id:"orderstatus"},"OrderStatus"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Definition"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"enum OrderStatus { NOT_EXIST, OPEN, PENDING_SETTLE, PURGED }")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"NOT_EXIST"),": Order has never been placed or has been cancelled"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"OPEN"),": Active order in the order book, available for matching against incoming orders"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"PENDING_SETTLE"),": Order has been filled"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"PURGED"),": Order was purged because rate is ",(0,a.kt)("a",{parentName:"li",href:"/Boros/Mechanics/OrderBook#restrictions"},"out of bound"))),(0,a.kt)("h2",{id:"market-types"},"Market Types"),(0,a.kt)("h3",{id:"tokenid"},"TokenId"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Definition"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"type TokenId is uint16")),(0,a.kt)("p",null,"Unique identifier for collateral tokens supported by the protocol."),(0,a.kt)("h3",{id:"marketid"},"MarketId"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Definition"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"type MarketId is uint24")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Special Value"),": The value ",(0,a.kt)("inlineCode",{parentName:"p"},"type(uint24).max")," (16,777,215) is reserved as ",(0,a.kt)("inlineCode",{parentName:"p"},"MarketIdLib.CROSS")," to indicate cross-margin mode, where collateral is shared across all markets within the same collateral zone."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// Cross-margin constant\nMarketId crossMargin = MarketIdLib.CROSS;  // type(uint24).max\n\n// Regular market IDs for isolated margin\nMarketId market1 = MarketId.wrap(1);       // Isolated margin for market 1\nMarketId market2 = MarketId.wrap(2);       // Isolated margin for market 2\n\n// Checking margin mode\nbool isCross = marketId.isCross();         // true if marketId == CROSS\n")),(0,a.kt)("h3",{id:"ammid"},"AMMId"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Definition"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"type AMMId is uint24")),(0,a.kt)("h2",{id:"advanced-types"},"Advanced Types"),(0,a.kt)("h3",{id:"findex"},"FIndex"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Definition"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"type FIndex is bytes26")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Bit Packing"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"fTime(32) | floatingIndex(112) | feeIndex(64)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"FIndex fIndex = FIndexLib.from(fTime, floatingIndex, feeIndex);\n\n// Parsing components\nuint32 fTime = fIndex.fTime();                  // Funding time\nint112 floatingIndex = fIndex.floatingIndex();  // Floating rate index\nuint64 feeIndex = fIndex.feeIndex();            // Fee accumulator\n\n// Comparison and checks\nbool isZero = fIndex.isZero();\nbool same = fIndex1 == fIndex2;\n")),(0,a.kt)("h3",{id:"vmresult"},"VMResult"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Definition"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"type VMResult is uint256")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Bit Packing"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"value(128) | margin(128)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"VMResult result = VMResultLib.from(positionValue, marginRequired);\n\n(int128 value, uint128 margin) = result.unpack();\n")))}u.isMDXComponent=!0}}]);