"use strict";(self.webpackChunkpendle_documentation=self.webpackChunkpendle_documentation||[]).push([[6543],{1254:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>a,frontMatter:()=>r,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"Developers/Contracts/PendleRouter/ApiReference/SimpleFunctions","title":"Simple Functions","description":"This document lists simplified versions of Pendle Router functions that use on-chain approximation algorithms instead of requiring complex parameters. These functions are automatically used by the main router when conditions allow for simplified execution.","source":"@site/docs/pendle-v2/Developers/Contracts/PendleRouter/ApiReference/SimpleFunctions.md","sourceDirName":"Developers/Contracts/PendleRouter/ApiReference","slug":"/Developers/Contracts/PendleRouter/ApiReference/SimpleFunctions","permalink":"/pendle-v2/Developers/Contracts/PendleRouter/ApiReference/SimpleFunctions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_table_of_contents":true},"sidebar":"myAutogeneratedSidebar","previous":{"title":"Misc Functions","permalink":"/pendle-v2/Developers/Contracts/PendleRouter/ApiReference/MiscFunctions"},"next":{"title":"sPENDLE","permalink":"/pendle-v2/Developers/Contracts/sPENDLE"}}');var s=i(4848),d=i(8453);const r={hide_table_of_contents:!0},l="Simple Functions",c={},h=[{value:"Overview",id:"overview",level:2},{value:"Important Notes",id:"important-notes",level:2},{value:"PT Trading Functions",id:"pt-trading-functions",level:2},{value:"swapExactTokenForPtSimple",id:"swapexacttokenforptsimple",level:3},{value:"swapExactSyForPtSimple",id:"swapexactsyforptsimple",level:3},{value:"YT Trading Functions",id:"yt-trading-functions",level:2},{value:"swapExactTokenForYtSimple",id:"swapexacttokenforytsimple",level:3},{value:"swapExactSyForYtSimple",id:"swapexactsyforytsimple",level:3},{value:"Liquidity Management Functions",id:"liquidity-management-functions",level:2},{value:"addLiquiditySingleTokenSimple",id:"addliquiditysingletokensimple",level:3},{value:"addLiquiditySingleSySimple",id:"addliquiditysinglesysimple",level:3},{value:"addLiquiditySinglePtSimple",id:"addliquiditysingleptsimple",level:3},{value:"removeLiquiditySinglePtSimple",id:"removeliquiditysingleptsimple",level:3},{value:"When Simple Functions Are Used",id:"when-simple-functions-are-used",level:2},{value:"Advantages of Simple Functions",id:"advantages-of-simple-functions",level:2},{value:"Integration Approach",id:"integration-approach",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"simple-functions",children:"Simple Functions"})}),"\n",(0,s.jsx)(n.p,{children:"This document lists simplified versions of Pendle Router functions that use on-chain approximation algorithms instead of requiring complex parameters. These functions are automatically used by the main router when conditions allow for simplified execution."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"The Pendle Router includes simplified versions of complex functions that:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use on-chain approximation algorithms (no ",(0,s.jsx)(n.code,{children:"ApproxParams"})," needed)"]}),"\n",(0,s.jsxs)(n.li,{children:["Skip limit order functionality (no ",(0,s.jsx)(n.code,{children:"LimitOrderData"})," needed)"]}),"\n",(0,s.jsx)(n.li,{children:"Provide streamlined interfaces for common operations"}),"\n",(0,s.jsx)(n.li,{children:"Are automatically selected when no off-chain guess is provided and limit order data is empty"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"important-notes",children:"Important Notes"}),"\n",(0,s.jsxs)(n.p,{children:["\u26a0\ufe0f ",(0,s.jsx)(n.strong,{children:"Limited Flexibility"}),": Simple functions don't support limit orders or custom approximation parameters."]}),"\n",(0,s.jsxs)(n.p,{children:["\u26a0\ufe0f ",(0,s.jsx)(n.strong,{children:"Market Dependent"}),": Effectiveness depends on current market conditions and may not always be available."]}),"\n",(0,s.jsx)(n.p,{children:"The simple functions provide a streamlined interface for common operations while maintaining the full functionality of the Pendle trading system through automated approximation algorithms."}),"\n",(0,s.jsx)(n.h2,{id:"pt-trading-functions",children:"PT Trading Functions"}),"\n",(0,s.jsx)(n.h3,{id:"swapexacttokenforptsimple",children:"swapExactTokenForPtSimple"}),"\n",(0,s.jsxs)(n.p,{children:["Simplified version of ",(0,s.jsx)(n.code,{children:"swapExactTokenForPt"})," using on-chain approximation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function swapExactTokenForPtSimple(\n    address receiver,\n    address market,\n    uint256 minPtOut,\n    TokenInput calldata input\n) external payable returns (uint256 netPtOut, uint256 netSyFee, uint256 netSyInterm)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"receiver"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address to receive PT tokens"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"market"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Pendle market address"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"minPtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Minimum PT tokens to receive"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"input"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"TokenInput"})}),(0,s.jsx)(n.td,{children:"Token input configuration"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netPtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"PT tokens received"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFee"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Trading fees paid in SY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyInterm"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"SY tokens generated from input token"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"swapexactsyforptsimple",children:"swapExactSyForPtSimple"}),"\n",(0,s.jsxs)(n.p,{children:["Simplified version of ",(0,s.jsx)(n.code,{children:"swapExactSyForPt"})," using on-chain approximation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function swapExactSyForPtSimple(\n    address receiver,\n    address market,\n    uint256 exactSyIn,\n    uint256 minPtOut\n) external returns (uint256 netPtOut, uint256 netSyFee)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"receiver"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address to receive PT tokens"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"market"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Pendle market address"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"exactSyIn"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Exact amount of SY tokens to swap"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"minPtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Minimum PT tokens to receive"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netPtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"PT tokens received"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFee"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Trading fees paid in SY"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"yt-trading-functions",children:"YT Trading Functions"}),"\n",(0,s.jsx)(n.h3,{id:"swapexacttokenforytsimple",children:"swapExactTokenForYtSimple"}),"\n",(0,s.jsxs)(n.p,{children:["Simplified version of ",(0,s.jsx)(n.code,{children:"swapExactTokenForYt"})," using on-chain approximation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function swapExactTokenForYtSimple(\n    address receiver,\n    address market,\n    uint256 minYtOut,\n    TokenInput calldata input\n) external payable returns (uint256 netYtOut, uint256 netSyFee, uint256 netSyInterm)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"receiver"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address to receive YT tokens"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"market"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Pendle market address"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"minYtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Minimum YT tokens to receive"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"input"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"TokenInput"})}),(0,s.jsx)(n.td,{children:"Token input configuration"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netYtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"YT tokens received"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFee"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Trading fees paid in SY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyInterm"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"SY tokens generated from input token"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"swapexactsyforytsimple",children:"swapExactSyForYtSimple"}),"\n",(0,s.jsxs)(n.p,{children:["Simplified version of ",(0,s.jsx)(n.code,{children:"swapExactSyForYt"})," using on-chain approximation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function swapExactSyForYtSimple(\n    address receiver,\n    address market,\n    uint256 exactSyIn,\n    uint256 minYtOut\n) external returns (uint256 netYtOut, uint256 netSyFee)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"receiver"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address to receive YT tokens"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"market"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Pendle market address"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"exactSyIn"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Exact amount of SY tokens to swap"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"minYtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Minimum YT tokens to receive"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netYtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"YT tokens received"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFee"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Trading fees paid in SY"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"liquidity-management-functions",children:"Liquidity Management Functions"}),"\n",(0,s.jsx)(n.h3,{id:"addliquiditysingletokensimple",children:"addLiquiditySingleTokenSimple"}),"\n",(0,s.jsxs)(n.p,{children:["Simplified version of ",(0,s.jsx)(n.code,{children:"addLiquiditySingleToken"})," using on-chain approximation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function addLiquiditySingleTokenSimple(\n    address receiver,\n    address market,\n    uint256 minLpOut,\n    TokenInput calldata input\n) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"receiver"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address to receive LP tokens"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"market"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Pendle market address"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"minLpOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Minimum LP tokens to receive"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"input"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"TokenInput"})}),(0,s.jsx)(n.td,{children:"Token input configuration"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netLpOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"LP tokens received"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFee"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Trading fees paid in SY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyInterm"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"SY tokens generated from input token"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"addliquiditysinglesysimple",children:"addLiquiditySingleSySimple"}),"\n",(0,s.jsxs)(n.p,{children:["Simplified version of ",(0,s.jsx)(n.code,{children:"addLiquiditySingleSy"})," using on-chain approximation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function addLiquiditySingleSySimple(\n    address receiver,\n    address market,\n    uint256 netSyIn,\n    uint256 minLpOut\n) external returns (uint256 netLpOut, uint256 netSyFee)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"receiver"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address to receive LP tokens"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"market"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Pendle market address"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyIn"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Amount of SY tokens to use"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"minLpOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Minimum LP tokens to receive"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netLpOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"LP tokens received"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFee"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Trading fees paid in SY"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"addliquiditysingleptsimple",children:"addLiquiditySinglePtSimple"}),"\n",(0,s.jsxs)(n.p,{children:["Simplified version of ",(0,s.jsx)(n.code,{children:"addLiquiditySinglePt"})," using on-chain approximation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function addLiquiditySinglePtSimple(\n    address receiver,\n    address market,\n    uint256 netPtIn,\n    uint256 minLpOut\n) external returns (uint256 netLpOut, uint256 netSyFee)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"receiver"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address to receive LP tokens"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"market"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Pendle market address"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netPtIn"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Amount of PT tokens to use"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"minLpOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Minimum LP tokens to receive"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netLpOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"LP tokens received"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFee"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Trading fees paid in SY"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"removeliquiditysingleptsimple",children:"removeLiquiditySinglePtSimple"}),"\n",(0,s.jsxs)(n.p,{children:["Simplified version of ",(0,s.jsx)(n.code,{children:"removeLiquiditySinglePt"})," using on-chain approximation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function removeLiquiditySinglePtSimple(\n    address receiver,\n    address market,\n    uint256 netLpToRemove,\n    uint256 minPtOut\n) external returns (uint256 netPtOut, uint256 netSyFee)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"receiver"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address to receive PT tokens"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"market"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Pendle market address"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netLpToRemove"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Amount of LP tokens to burn"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"minPtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Minimum PT tokens to receive"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netPtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"PT tokens received"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFee"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Trading fees paid in SY"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"when-simple-functions-are-used",children:"When Simple Functions Are Used"}),"\n",(0,s.jsx)(n.p,{children:"The Pendle Router automatically determines when to use simplified functions. Simple functions are used when:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No limit orders"}),": ",(0,s.jsx)(n.code,{children:"LimitOrderData"})," is empty"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No off-chain guess"}),": ",(0,s.jsx)(n.code,{children:"ApproxParams"})," doesn't include off-chain calculated estimates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Default parameters"}),": Standard approximation parameters are used"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"advantages-of-simple-functions",children:"Advantages of Simple Functions"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Ease of Use"}),": Require fewer parameters and no complex configuration."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Reliability"}),": Built-in approximation algorithms are optimized for common trading scenarios."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Automatic Selection"}),": The main router functions automatically delegate to simple versions when no off-chain guess is provided and limit order data is empty."]}),"\n",(0,s.jsx)(n.h2,{id:"integration-approach",children:"Integration Approach"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Recommended Pattern"}),": Always use the main router functions (e.g., ",(0,s.jsx)(n.code,{children:"swapExactTokenForPt"}),") with default parameters. The router will automatically use simple versions when optimal."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// This may automatically use the simple version\nrouter.swapExactTokenForPt(\n    receiver,\n    market,\n    minPtOut,\n    createDefaultApproxParams(),\n    createTokenInputSimple(tokenIn, amountIn),\n    createEmptyLimitOrderData()\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Direct Usage"}),": Only call simple functions directly if you're building custom routing logic and want to force the use of on-chain approximation."]})]})}function a(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var t=i(6540);const s={},d=t.createContext(s);function r(e){const n=t.useContext(d);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(d.Provider,{value:n},e.children)}}}]);