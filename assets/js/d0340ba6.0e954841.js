"use strict";(self.webpackChunkpendle_documentation=self.webpackChunkpendle_documentation||[]).push([[2832],{3905:(t,e,a)=>{a.d(e,{Zo:()=>m,kt:()=>N});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function p(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var o=n.createContext({}),u=function(t){var e=n.useContext(o),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},m=function(t){var e=u(t.components);return n.createElement(o.Provider,{value:e},t.children)},d="mdxType",s={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},k=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,o=t.parentName,m=p(t,["components","mdxType","originalType","parentName"]),d=u(a),k=r,N=d["".concat(o,".").concat(k)]||d[k]||s[k]||l;return a?n.createElement(N,i(i({ref:e},m),{},{components:a})):n.createElement(N,i({ref:e},m))}));function N(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,i=new Array(l);i[0]=k;var p={};for(var o in e)hasOwnProperty.call(e,o)&&(p[o]=e[o]);p.originalType=t,p[d]="string"==typeof t?t:r,i[1]=p;for(var u=2;u<l;u++)i[u]=a[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},2937:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>o,contentTitle:()=>i,default:()=>s,frontMatter:()=>l,metadata:()=>p,toc:()=>u});var n=a(7462),r=(a(7294),a(3905));const l={hide_table_of_contents:!0},i="Types and Utility Functions",p={unversionedId:"Developers/Contracts/PendleRouter/ApiReference/Types",id:"Developers/Contracts/PendleRouter/ApiReference/Types",title:"Types and Utility Functions",description:"This document covers all struct types used throughout the Pendle Router and utility functions for generating parameters on-chain.",source:"@site/docs/Developers/Contracts/PendleRouter/ApiReference/Types.md",sourceDirName:"Developers/Contracts/PendleRouter/ApiReference",slug:"/Developers/Contracts/PendleRouter/ApiReference/Types",permalink:"/Developers/Contracts/PendleRouter/ApiReference/Types",draft:!1,tags:[],version:"current",frontMatter:{hide_table_of_contents:!0},sidebar:"myAutogeneratedSidebar",previous:{title:"Pendle Router Contract Integration Guide",permalink:"/Developers/Contracts/PendleRouter/ContractIntegrationGuide"},next:{title:"Principal Token (PT) Trading Functions",permalink:"/Developers/Contracts/PendleRouter/ApiReference/PtFunctions"}},o={},u=[{value:"Core Parameter Types",id:"core-parameter-types",level:2},{value:"TokenInput",id:"tokeninput",level:3},{value:"Usage Patterns",id:"usage-patterns",level:3},{value:"TokenOutput",id:"tokenoutput",level:3},{value:"Usage Patterns",id:"usage-patterns-1",level:3},{value:"ApproxParams",id:"approxparams",level:3},{value:"LimitOrderData",id:"limitorderdata",level:3},{value:"RedeemYtIncomeToTokenStruct",id:"redeemytincometotokenstruct",level:3},{value:"SwapData",id:"swapdata",level:3},{value:"SwapType",id:"swaptype",level:3},{value:"ExitPreExpReturnParams",id:"exitpreexpreturnparams",level:3},{value:"ExitPostExpReturnParams",id:"exitpostexpreturnparams",level:3},{value:"Utility Functions",id:"utility-functions",level:2},{value:"createTokenInputSimple",id:"createtokeninputsimple",level:3},{value:"createTokenOutputSimple",id:"createtokenoutputsimple",level:3},{value:"createDefaultApproxParams",id:"createdefaultapproxparams",level:3},{value:"createEmptyLimitOrderData",id:"createemptylimitorderdata",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Basic Parameter Creation",id:"basic-parameter-creation",level:3},{value:"Complete Function Call Example",id:"complete-function-call-example",level:3},{value:"Custom ApproxParams for Advanced Use",id:"custom-approxparams-for-advanced-use",level:3},{value:"Best Practices",id:"best-practices",level:2}],m={toc:u},d="wrapper";function s(t){let{components:e,...a}=t;return(0,r.kt)(d,(0,n.Z)({},m,a,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"types-and-utility-functions"},"Types and Utility Functions"),(0,r.kt)("p",null,"This document covers all struct types used throughout the Pendle Router and utility functions for generating parameters on-chain."),(0,r.kt)("h2",{id:"core-parameter-types"},"Core Parameter Types"),(0,r.kt)("h3",{id:"tokeninput"},"TokenInput"),(0,r.kt)("p",null,"Defines input token configuration for functions that accept tokens."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"struct TokenInput {\n    address tokenIn;\n    uint256 netTokenIn;\n    address tokenMintSy;\n    address pendleSwap;\n    SwapData swapData;\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Fields")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tokenIn"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"address")),(0,r.kt)("td",{parentName:"tr",align:null},"Address of the input token (can be any ERC20 token supported by Pendle)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"netTokenIn"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"Amount of input tokens")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tokenMintSy"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"address")),(0,r.kt)("td",{parentName:"tr",align:null},"Token used to mint SY (must be supported by target SY contract)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pendleSwap"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"address")),(0,r.kt)("td",{parentName:"tr",align:null},"Swap aggregator address (use ",(0,r.kt)("inlineCode",{parentName:"td"},"address(0)")," for direct SY token input)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"swapData"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"SwapData")),(0,r.kt)("td",{parentName:"tr",align:null},"Swap configuration data for external aggregation")))),(0,r.kt)("h3",{id:"usage-patterns"},"Usage Patterns"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Direct SY Token Input (Simple):"),"\nWhen ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenIn")," is already a token supported by the target SY contract:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"tokenIn = tokenMintSy")," (same token)"),(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"pendleSwap = address(0)")," (no external swap needed)"),(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"swapData")," to empty (no aggregation)")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Any ERC20 Token Input (Zap In):"),"\nWhen ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenIn")," is any ERC20 token that needs to be swapped to a supported SY token:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Set ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenIn")," to the user's input token (e.g., USDC, DAI, WETH)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Set ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenMintSy")," to a token supported by the target SY")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Set ",(0,r.kt)("inlineCode",{parentName:"p"},"pendleSwap")," to the swap aggregator address")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Set ",(0,r.kt)("inlineCode",{parentName:"p"},"swapData")," with proper aggregator configuration."),(0,r.kt)("p",{parentName:"li"},"  ",(0,r.kt)("strong",{parentName:"p"},"E.g"),": When you had USDC token and want to mint SY-sUSDe:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"tokenIn = USDC")),(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"tokenMintSy = SY-sUSDe")),(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"pendleSwap = 0xd4F480965D2347d421F1bEC7F545682E5Ec2151D")),(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"swapData")," to proper data configuration obtained from ",(0,r.kt)("a",{parentName:"li",href:"/Developers/Backend/BackendAndHostedSDK#supported-functions"},"SDK"))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Benefits of Zap In:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Users can interact with any Pendle market using any ERC20 token they hold"),(0,r.kt)("li",{parentName:"ul"},"No need to manually swap tokens before interacting with Pendle"),(0,r.kt)("li",{parentName:"ul"},"Optimal routing through multiple DEXes for best price execution"),(0,r.kt)("li",{parentName:"ul"},"Single transaction for swap + Pendle operation")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"SDK Integration:"),"\nThe ",(0,r.kt)("a",{parentName:"p",href:"/Developers/Backend/BackendAndHostedSDK#features"},"Pendle Hosted SDK")," automatically handles all TokenInput configuration when you enable routing. When you set ",(0,r.kt)("inlineCode",{parentName:"p"},"enableAggregator: true")," in SDK calls, it:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Automatically selects the best swap aggregator (KyberSwap, ODOS, 1inch, etc.)"),(0,r.kt)("li",{parentName:"ul"},"Generates optimal ",(0,r.kt)("inlineCode",{parentName:"li"},"swapData")," for the chosen route"),(0,r.kt)("li",{parentName:"ul"},"Handles all token conversions transparently"),(0,r.kt)("li",{parentName:"ul"},"Provides the best possible price execution across multiple DEXes")),(0,r.kt)("p",null,"For direct contract interaction, you need to manually configure these fields or use utility functions like ",(0,r.kt)("inlineCode",{parentName:"p"},"createTokenInputSimple()")," for basic operations."),(0,r.kt)("h3",{id:"tokenoutput"},"TokenOutput"),(0,r.kt)("p",null,"Defines output token configuration for functions that return tokens."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"struct TokenOutput {\n    address tokenOut;\n    uint256 minTokenOut;\n    address tokenRedeemSy;\n    address pendleSwap;\n    SwapData swapData;\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Fields")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tokenOut"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"address")),(0,r.kt)("td",{parentName:"tr",align:null},"Address of the desired output token (can be any ERC20 token supported by Pendle)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"minTokenOut"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"Minimum amount of output tokens to receive (slippage protection)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tokenRedeemSy"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"address")),(0,r.kt)("td",{parentName:"tr",align:null},"Token to redeem SY to (must be supported by target SY contract)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pendleSwap"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"address")),(0,r.kt)("td",{parentName:"tr",align:null},"Swap aggregator address (use ",(0,r.kt)("inlineCode",{parentName:"td"},"address(0)")," for direct SY token output)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"swapData"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"SwapData")),(0,r.kt)("td",{parentName:"tr",align:null},"Swap configuration data for external aggregation")))),(0,r.kt)("h3",{id:"usage-patterns-1"},"Usage Patterns"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Direct SY Token Output (Simple):"),"\nWhen ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenOut")," is already a token supported by the target SY contract:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"tokenOut = tokenRedeemSy")," (same token)"),(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"pendleSwap = address(0)")," (no external swap needed)"),(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"swapData")," to empty (no aggregation)")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Any ERC20 Token Output (Zap Out):"),"\nWhen ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenOut")," is any ERC20 token different from supported SY tokens:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"tokenOut")," to the user's desired token (e.g., USDC, DAI, WETH)"),(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"tokenRedeemSy")," to a token supported by the target SY"),(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"pendleSwap")," to the swap aggregator address"),(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"swapData")," with proper aggregator configuration (KyberSwap, 1inch, etc.)")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Benefits of Zap Out:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Users can receive any ERC20 token as output from Pendle operations"),(0,r.kt)("li",{parentName:"ul"},"No need to manually swap tokens after exiting Pendle positions"),(0,r.kt)("li",{parentName:"ul"},"Optimal routing through multiple DEXes for best price execution"),(0,r.kt)("li",{parentName:"ul"},"Single transaction for Pendle operation + swap"),(0,r.kt)("li",{parentName:"ul"},"Built-in slippage protection with ",(0,r.kt)("inlineCode",{parentName:"li"},"minTokenOut"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"SDK Integration:"),"\nThe ",(0,r.kt)("a",{parentName:"p",href:"/Developers/Backend/BackendAndHostedSDK#features"},"Pendle Hosted SDK")," automatically handles all TokenOutput configuration when you enable routing. When you set ",(0,r.kt)("inlineCode",{parentName:"p"},"enableAggregator: true")," in SDK calls, it:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Automatically selects the best swap aggregator for output token conversion"),(0,r.kt)("li",{parentName:"ul"},"Generates optimal ",(0,r.kt)("inlineCode",{parentName:"li"},"swapData")," for the chosen route"),(0,r.kt)("li",{parentName:"ul"},"Calculates appropriate slippage protection"),(0,r.kt)("li",{parentName:"ul"},"Handles all token conversions transparently")),(0,r.kt)("p",null,"For direct contract interaction, you need to manually configure these fields or use utility functions like ",(0,r.kt)("inlineCode",{parentName:"p"},"createTokenOutputSimple()")," for basic operations."),(0,r.kt)("h3",{id:"approxparams"},"ApproxParams"),(0,r.kt)("p",null,"Parameters for approximation algorithms used when swapping exact tokens to PT or YT. ",(0,r.kt)("strong",{parentName:"p"},"ApproxParams is required when the exact output amount needs to be determined through iterative approximation")," because the Pendle AMM formula cannot be directly inverted."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"struct ApproxParams {\n    uint256 guessMin;\n    uint256 guessMax;\n    uint256 guessOffchain;\n    uint256 maxIteration;\n    uint256 eps;\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Fields")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"guessMin"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"Minimum bound for binary search")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"guessMax"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"Maximum bound for binary search (use ",(0,r.kt)("inlineCode",{parentName:"td"},"type(uint256).max")," for auto)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"guessOffchain"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"Initial guess from off-chain calculation (use ",(0,r.kt)("inlineCode",{parentName:"td"},"0")," for on-chain)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"maxIteration"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"Maximum iterations for binary search (recommended: ",(0,r.kt)("inlineCode",{parentName:"td"},"256"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"eps"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"Precision tolerance (recommended: ",(0,r.kt)("inlineCode",{parentName:"td"},"1e14"),")")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"When ApproxParams is Needed:")),(0,r.kt)("p",null,"ApproxParams is required for functions that swap an exact amount of tokens to PT or YT, such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/Developers/Contracts/PendleRouter/ApiReference/PtFunctions#swapexacttokenforpt"},(0,r.kt)("inlineCode",{parentName:"a"},"swapExactTokenForPt"))," - Convert exact token amount to PT"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/Developers/Contracts/PendleRouter/ApiReference/PtFunctions#swapexactsyforpt"},(0,r.kt)("inlineCode",{parentName:"a"},"swapExactSyForPt"))," - Convert exact SY amount to PT"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/Developers/Contracts/PendleRouter/ApiReference/YtFunctions#swapexacttokenforyt"},(0,r.kt)("inlineCode",{parentName:"a"},"swapExactTokenForYt"))," - Convert exact token amount to YT"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/Developers/Contracts/PendleRouter/ApiReference/YtFunctions#swapexactsyforyt"},(0,r.kt)("inlineCode",{parentName:"a"},"swapExactSyForYt"))," - Convert exact SY amount to YT")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Why Approximation is Required:"),"\nThe Pendle AMM natively supports functions like ",(0,r.kt)("inlineCode",{parentName:"p"},"swapExactPtForSy")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"swapSyForExactPt"),", but does NOT have ",(0,r.kt)("inlineCode",{parentName:"p"},"swapExactSyForPt"),". When you want to swap an exact amount of tokens/SY for PT/YT, the router must use binary search to determine how much PT/YT can be obtained, since the AMM can only calculate the reverse (exact PT amounts)."),(0,r.kt)("h3",{id:"limitorderdata"},"LimitOrderData"),(0,r.kt)("p",null,"Configuration for limit order functionality that ",(0,r.kt)("strong",{parentName:"p"},"provides better prices and reduces slippage")," by filling user orders at predetermined rates before routing to the AMM."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"struct LimitOrderData {\n    address limitRouter;\n    uint256 epsSkipMarket;\n    FillOrderParams[] normalFills;\n    FillOrderParams[] flashFills;\n    bytes optData;\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Fields")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"limitRouter"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"address")),(0,r.kt)("td",{parentName:"tr",align:null},"Address of limit order router")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"epsSkipMarket"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"Threshold to skip market operations")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"normalFills"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"FillOrderParams[]")),(0,r.kt)("td",{parentName:"tr",align:null},"Normal limit order fills")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flashFills"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"FillOrderParams[]")),(0,r.kt)("td",{parentName:"tr",align:null},"Flash loan limit order fills")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"optData"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bytes")),(0,r.kt)("td",{parentName:"tr",align:null},"Additional optimization data")))),(0,r.kt)("h3",{id:"redeemytincometotokenstruct"},"RedeemYtIncomeToTokenStruct"),(0,r.kt)("p",null,"Configuration for YT income redemption with token conversion."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"struct RedeemYtIncomeToTokenStruct {\n    IPYieldToken yt;\n    bool doRedeemInterest;\n    bool doRedeemRewards;\n    address tokenRedeemSy;\n    uint256 minTokenRedeemOut;\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Fields")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"yt"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"IPYieldToken")),(0,r.kt)("td",{parentName:"tr",align:null},"YT token contract interface")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"doRedeemInterest"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to redeem accrued interest")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"doRedeemRewards"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to redeem reward tokens")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tokenRedeemSy"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"address")),(0,r.kt)("td",{parentName:"tr",align:null},"Token to convert SY interest to")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"minTokenRedeemOut"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"Minimum tokens to receive from conversion")))),(0,r.kt)("h3",{id:"swapdata"},"SwapData"),(0,r.kt)("p",null,"Configuration for external swap aggregation functionality."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"struct SwapData {\n    SwapType swapType;\n    address extRouter;\n    bytes extCalldata;\n    bool needScale;\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Fields")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"swapType"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"SwapType")),(0,r.kt)("td",{parentName:"tr",align:null},"Type of swap aggregator to use")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"extRouter"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"address")),(0,r.kt)("td",{parentName:"tr",align:null},"Address of the external swap router")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"extCalldata"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bytes")),(0,r.kt)("td",{parentName:"tr",align:null},"Encoded calldata for the external swap")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"needScale"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether the swap amount needs scaling")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use Case"),"\nEnables integration with external swap aggregators like KyberSwap, 1inch, Paraswap, etc. This allows Pendle to support zapping in/out with any ERC20 token by routing through external DEXes."),(0,r.kt)("h3",{id:"swaptype"},"SwapType"),(0,r.kt)("p",null,"Enumeration defining supported swap aggregator types. See the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/pendle-finance/pendle-core-v2-public/blob/main/contracts/router/swap-aggregator/IPSwapAggregator.sol#L18-L31"},"complete SwapType definition")," in the smart contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"enum SwapType {\n    NONE,\n    KYBERSWAP,\n    ODOS,\n    ETH_WETH,\n    OKX,\n    ONE_INCH,\n    PARASWAP\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Values")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"NONE")),(0,r.kt)("td",{parentName:"tr",align:null},"No external swap aggregation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"KYBERSWAP")),(0,r.kt)("td",{parentName:"tr",align:null},"KyberSwap aggregation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ODOS")),(0,r.kt)("td",{parentName:"tr",align:null},"ODOS aggregation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ETH_WETH")),(0,r.kt)("td",{parentName:"tr",align:null},"ETH/WETH conversion")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"OKX")),(0,r.kt)("td",{parentName:"tr",align:null},"OKX DEX aggregation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ONE_INCH")),(0,r.kt)("td",{parentName:"tr",align:null},"1inch aggregation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"PARASWAP")),(0,r.kt)("td",{parentName:"tr",align:null},"Paraswap aggregation")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use Case"),"\nSpecifies which external aggregator to use for token swaps, enabling Pendle to leverage the best available liquidity across different DEXes. The ",(0,r.kt)("a",{parentName:"p",href:"/Developers/Backend/BackendAndHostedSDK#features"},"Pendle Hosted SDK")," automatically selects the optimal SwapType based on available liquidity and routing efficiency."),(0,r.kt)("h3",{id:"exitpreexpreturnparams"},"ExitPreExpReturnParams"),(0,r.kt)("p",null,"Detailed breakdown of returns from pre-expiry position exit operations."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"struct ExitPreExpReturnParams {\n    uint256 netPtFromRemove;\n    uint256 netSyFromRemove;\n    uint256 netPyRedeem;\n    uint256 netSyFromRedeem;\n    uint256 netPtSwap;\n    uint256 netYtSwap;\n    uint256 netSyFromSwap;\n    uint256 netSyFee;\n    uint256 totalSyOut;\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Fields")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"netPtFromRemove"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"PT tokens obtained from LP removal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"netSyFromRemove"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"SY tokens obtained from LP removal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"netPyRedeem"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"PT+YT pairs redeemed to SY")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"netSyFromRedeem"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"SY tokens from PT+YT redemption")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"netPtSwap"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"PT tokens swapped to SY")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"netYtSwap"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"YT tokens swapped to SY")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"netSyFromSwap"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"SY tokens from PT/YT swaps")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"netSyFee"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"Trading fees paid in SY")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"totalSyOut"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"Total SY tokens received")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use Case"),"\nProvides detailed breakdown of complex exit operations before market expiry, helping users understand exactly how their positions were unwound and what fees were paid."),(0,r.kt)("h3",{id:"exitpostexpreturnparams"},"ExitPostExpReturnParams"),(0,r.kt)("p",null,"Breakdown of returns from post-expiry position exit operations."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"struct ExitPostExpReturnParams {\n    uint256 netPtFromRemove;\n    uint256 netSyFromRemove;\n    uint256 netPtRedeem;\n    uint256 netSyFromRedeem;\n    uint256 totalSyOut;\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Fields")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"netPtFromRemove"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"PT tokens obtained from LP removal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"netSyFromRemove"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"SY tokens obtained from LP removal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"netPtRedeem"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"PT tokens redeemed at maturity")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"netSyFromRedeem"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"SY tokens from PT redemption")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"totalSyOut"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"Total SY tokens received")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use Case"),"\nProvides breakdown of exit operations after market expiry when PT tokens can be redeemed 1:1 for underlying assets. Simpler than pre-expiry exits since no swapping is required."),(0,r.kt)("h2",{id:"utility-functions"},"Utility Functions"),(0,r.kt)("p",null,"These functions generate the parameters described above on-chain, offering an alternative for users who do not utilize the Pendle SDK."),(0,r.kt)("h3",{id:"createtokeninputsimple"},"createTokenInputSimple"),(0,r.kt)("p",null,"Creates a simple TokenInput struct without external swapping."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function createTokenInputSimple(address tokenIn, uint256 netTokenIn) pure returns (TokenInput memory)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input Parameters")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tokenIn"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"address")),(0,r.kt)("td",{parentName:"tr",align:null},"Input token address (must be supported by target SY)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"netTokenIn"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"Amount of input tokens")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Return Values")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"-"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"TokenInput")),(0,r.kt)("td",{parentName:"tr",align:null},"Configured TokenInput struct")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use Case"),"\nMost common way to create TokenInput for standard operations. The tokenIn must be one of the tokens accepted by the target SY contract (check via ",(0,r.kt)("inlineCode",{parentName:"p"},"IStandardizedYield.getTokensIn()"),")."),(0,r.kt)("h3",{id:"createtokenoutputsimple"},"createTokenOutputSimple"),(0,r.kt)("p",null,"Creates a simple TokenOutput struct without external swapping."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function createTokenOutputSimple(address tokenOut, uint256 minTokenOut) pure returns (TokenOutput memory)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input Parameters")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tokenOut"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"address")),(0,r.kt)("td",{parentName:"tr",align:null},"Output token address (must be supported by target SY)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"minTokenOut"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint256")),(0,r.kt)("td",{parentName:"tr",align:null},"Minimum amount of output tokens")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Return Values")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"-"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"TokenOutput")),(0,r.kt)("td",{parentName:"tr",align:null},"Configured TokenOutput struct")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use Case"),"\nMost common way to create TokenOutput for standard operations. The tokenOut must be one of the tokens that the target SY can redeem to (check via ",(0,r.kt)("inlineCode",{parentName:"p"},"IStandardizedYield.getTokensOut()"),")."),(0,r.kt)("h3",{id:"createdefaultapproxparams"},"createDefaultApproxParams"),(0,r.kt)("p",null,"Creates default approximation parameters suitable for most operations."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function createDefaultApproxParams() pure returns (ApproxParams memory)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Return Values")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"-"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ApproxParams")),(0,r.kt)("td",{parentName:"tr",align:null},"Configured ApproxParams with optimal defaults")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Configuration")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"guessMin: ",(0,r.kt)("inlineCode",{parentName:"li"},"0")),(0,r.kt)("li",{parentName:"ul"},"guessMax: ",(0,r.kt)("inlineCode",{parentName:"li"},"type(uint256).max")," (auto-detection)"),(0,r.kt)("li",{parentName:"ul"},"guessOffchain: ",(0,r.kt)("inlineCode",{parentName:"li"},"0")," (pure on-chain calculation)"),(0,r.kt)("li",{parentName:"ul"},"maxIteration: ",(0,r.kt)("inlineCode",{parentName:"li"},"256")," (sufficient for most cases)"),(0,r.kt)("li",{parentName:"ul"},"eps: ",(0,r.kt)("inlineCode",{parentName:"li"},"1e14")," (0.01% precision)")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use Case"),"\nRecommended for all operations requiring approximation. These parameters provide good balance between accuracy and gas costs."),(0,r.kt)("h3",{id:"createemptylimitorderdata"},"createEmptyLimitOrderData"),(0,r.kt)("p",null,"Creates an empty LimitOrderData struct for operations without limit orders."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function createEmptyLimitOrderData() pure returns (LimitOrderData memory)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Return Values")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"-"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"LimitOrderData")),(0,r.kt)("td",{parentName:"tr",align:null},"Empty LimitOrderData struct")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use Case"),"\nUse when you don't need limit order functionality. Required by many functions but can be empty for standard market operations."),(0,r.kt)("h2",{id:"integration-examples"},"Integration Examples"),(0,r.kt)("h3",{id:"basic-parameter-creation"},"Basic Parameter Creation"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"// Create input parameters for 1000 USDC\nTokenInput memory input = createTokenInputSimple(USDC_ADDRESS, 1000e6);\n\n// Create output parameters expecting at least 950 USDC\nTokenOutput memory output = createTokenOutputSimple(USDC_ADDRESS, 950e6);\n\n// Create default approximation parameters\nApproxParams memory approx = createDefaultApproxParams();\n\n// Create empty limit order data\nLimitOrderData memory limit = createEmptyLimitOrderData();\n")),(0,r.kt)("h3",{id:"complete-function-call-example"},"Complete Function Call Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"// Add liquidity with properly configured parameters\nrouter.addLiquiditySingleToken(\n    msg.sender,                                           // receiver\n    MARKET_ADDRESS,                                       // market\n    minLpOut,                                            // minLpOut\n    createDefaultApproxParams(),                         // guessPtReceivedFromSy\n    createTokenInputSimple(USDC_ADDRESS, 1000e6),        // input\n    createEmptyLimitOrderData()                          // limit\n);\n")),(0,r.kt)("h3",{id:"custom-approxparams-for-advanced-use"},"Custom ApproxParams for Advanced Use"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"// Create custom approximation parameters for high precision\nApproxParams memory customApprox = ApproxParams({\n    guessMin: 0,\n    guessMax: type(uint256).max,\n    guessOffchain: estimatedOutput,  // Use off-chain calculation if available\n    maxIteration: 512,               // Higher precision\n    eps: 1e15                        // Tighter tolerance (0.001%)\n});\n")),(0,r.kt)("h2",{id:"best-practices"},"Best Practices"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"For Standard Operations:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Always use ",(0,r.kt)("inlineCode",{parentName:"li"},"createDefaultApproxParams()")," unless you have specific precision requirements"),(0,r.kt)("li",{parentName:"ul"},"Use ",(0,r.kt)("inlineCode",{parentName:"li"},"createEmptyLimitOrderData()")," for simple market operations"),(0,r.kt)("li",{parentName:"ul"},"Ensure token addresses are supported by target SY contracts")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"For Performance:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Off-chain approximation (",(0,r.kt)("inlineCode",{parentName:"li"},"guessOffchain"),") can reduce gas costs significantly"),(0,r.kt)("li",{parentName:"ul"},"Higher ",(0,r.kt)("inlineCode",{parentName:"li"},"maxIteration")," values increase precision but cost more gas"),(0,r.kt)("li",{parentName:"ul"},"Tighter ",(0,r.kt)("inlineCode",{parentName:"li"},"eps")," values improve precision but may increase iterations")))}s.isMDXComponent=!0}}]);