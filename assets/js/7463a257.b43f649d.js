"use strict";(self.webpackChunkpendle_documentation=self.webpackChunkpendle_documentation||[]).push([[5318],{5045:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>a,frontMatter:()=>r,metadata:()=>d,toc:()=>h});const d=JSON.parse('{"id":"Developers/Contracts/PendleRouter/ApiReference/LiquidityFunctions","title":"Liquidity Management Functions","description":"This document covers all functions for managing liquidity positions in Pendle markets. These functions allow adding and removing liquidity in various token combinations.","source":"@site/docs/pendle-v2/Developers/Contracts/PendleRouter/ApiReference/LiquidityFunctions.md","sourceDirName":"Developers/Contracts/PendleRouter/ApiReference","slug":"/Developers/Contracts/PendleRouter/ApiReference/LiquidityFunctions","permalink":"/pendle-v2/Developers/Contracts/PendleRouter/ApiReference/LiquidityFunctions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_table_of_contents":true},"sidebar":"myAutogeneratedSidebar","previous":{"title":"Yield Token (YT) Trading Functions","permalink":"/pendle-v2/Developers/Contracts/PendleRouter/ApiReference/YtFunctions"},"next":{"title":"Misc Functions","permalink":"/pendle-v2/Developers/Contracts/PendleRouter/ApiReference/MiscFunctions"}}');var t=i(4848),s=i(8453);const r={hide_table_of_contents:!0},l="Liquidity Management Functions",c={},h=[{value:"Add Liquidity Functions",id:"add-liquidity-functions",level:2},{value:"addLiquidityDualTokenAndPt",id:"addliquiditydualtokenandpt",level:3},{value:"addLiquidityDualSyAndPt",id:"addliquiditydualsyandpt",level:3},{value:"addLiquiditySinglePt",id:"addliquiditysinglept",level:3},{value:"addLiquiditySingleToken",id:"addliquiditysingletoken",level:3},{value:"addLiquiditySingleSy",id:"addliquiditysinglesy",level:3},{value:"addLiquiditySingleTokenKeepYt",id:"addliquiditysingletokenkeepyt",level:3},{value:"addLiquiditySingleSyKeepYt",id:"addliquiditysinglesykeepyt",level:3},{value:"Remove Liquidity Functions",id:"remove-liquidity-functions",level:2},{value:"removeLiquidityDualTokenAndPt",id:"removeliquiditydualtokenandpt",level:3},{value:"removeLiquidityDualSyAndPt",id:"removeliquiditydualsyandpt",level:3},{value:"removeLiquiditySinglePt",id:"removeliquiditysinglept",level:3},{value:"removeLiquiditySingleToken",id:"removeliquiditysingletoken",level:3},{value:"removeLiquiditySingleSy",id:"removeliquiditysinglesy",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Basic Liquidity Addition",id:"basic-liquidity-addition",level:3},{value:"Basic Liquidity Removal",id:"basic-liquidity-removal",level:3}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"liquidity-management-functions",children:"Liquidity Management Functions"})}),"\n",(0,t.jsx)(n.p,{children:"This document covers all functions for managing liquidity positions in Pendle markets. These functions allow adding and removing liquidity in various token combinations."}),"\n",(0,t.jsx)(n.h2,{id:"add-liquidity-functions",children:"Add Liquidity Functions"}),"\n",(0,t.jsx)(n.h3,{id:"addliquiditydualtokenandpt",children:"addLiquidityDualTokenAndPt"}),"\n",(0,t.jsx)(n.p,{children:"Adds liquidity using a token and PT token in exact amounts."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"function addLiquidityDualTokenAndPt(\n    address receiver,\n    address market,\n    TokenInput calldata input,\n    uint256 netPtDesired,\n    uint256 minLpOut\n) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"receiver"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Address to receive LP tokens"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"market"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Pendle market address"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"input"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/types#tokeninput",children:(0,t.jsx)(n.code,{children:"TokenInput"})})}),(0,t.jsx)(n.td,{children:"Token input configuration"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netPtDesired"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Desired amount of PT tokens to use"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"minLpOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Minimum LP tokens to receive"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netLpOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"LP tokens received"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netPtUsed"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"PT tokens actually used"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyInterm"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"SY tokens generated from input token"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),"\nWhen you have both the underlying token and PT tokens and want to add liquidity using exact amounts of both. The function will mint SY from your token input and combine it with your PT tokens."]}),"\n",(0,t.jsx)(n.h3,{id:"addliquiditydualsyandpt",children:"addLiquidityDualSyAndPt"}),"\n",(0,t.jsx)(n.p,{children:"Adds liquidity using both SY and PT tokens in exact amounts."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"function addLiquidityDualSyAndPt(\n    address receiver,\n    address market,\n    uint256 netSyDesired,\n    uint256 netPtDesired,\n    uint256 minLpOut\n) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"receiver"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Address to receive LP tokens"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"market"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Pendle market address"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyDesired"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Desired amount of SY tokens to use"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netPtDesired"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Desired amount of PT tokens to use"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"minLpOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Minimum LP tokens to receive"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netLpOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"LP tokens received"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyUsed"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"SY tokens actually used"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netPtUsed"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"PT tokens actually used"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),"\nWhen you already have both SY and PT tokens and want to add liquidity directly."]}),"\n",(0,t.jsx)(n.h3,{id:"addliquiditysinglept",children:"addLiquiditySinglePt"}),"\n",(0,t.jsx)(n.p,{children:"Adds liquidity using only PT tokens by internally swapping some PT for SY."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"function addLiquiditySinglePt(\n    address receiver,\n    address market,\n    uint256 netPtIn,\n    uint256 minLpOut,\n    ApproxParams calldata guessPtSwapToSy,\n    LimitOrderData calldata limit\n) external returns (uint256 netLpOut, uint256 netSyFee)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"receiver"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Address to receive LP tokens"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"market"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Pendle market address"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netPtIn"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Amount of PT tokens to use"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"minLpOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Minimum LP tokens to receive"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"guessPtSwapToSy"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/types#approxparams",children:(0,t.jsx)(n.code,{children:"ApproxParams"})})}),(0,t.jsx)(n.td,{children:"Approximation parameters"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"limit"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/types#limitorderdata",children:(0,t.jsx)(n.code,{children:"LimitOrderData"})})}),(0,t.jsx)(n.td,{children:"Limit order configuration"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netLpOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"LP tokens received"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyFee"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Trading fees paid in SY"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),"\nWhen you only have PT tokens and want to add liquidity. The function will automatically determine the optimal amount of PT to swap for SY to achieve balanced liquidity provision."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Simple Version Available"}),"\nFor basic operations without custom parameters, use ",(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/SimpleFunctions#addliquiditysingleptSimple",children:(0,t.jsx)(n.code,{children:"addLiquiditySinglePtSimple"})})," which automatically handles approximation and skips limit order functionality."]}),"\n",(0,t.jsx)(n.h3,{id:"addliquiditysingletoken",children:"addLiquiditySingleToken"}),"\n",(0,t.jsx)(n.p,{children:"Adds liquidity using any supported token by converting it to SY and PT as needed."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"function addLiquiditySingleToken(\n    address receiver,\n    address market,\n    uint256 minLpOut,\n    ApproxParams calldata guessPtReceivedFromSy,\n    TokenInput calldata input,\n    LimitOrderData calldata limit\n) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"receiver"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Address to receive LP tokens"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"market"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Pendle market address"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"minLpOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Minimum LP tokens to receive"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"guessPtReceivedFromSy"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/types#approxparams",children:(0,t.jsx)(n.code,{children:"ApproxParams"})})}),(0,t.jsx)(n.td,{children:"Approximation parameters"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"input"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/types#tokeninput",children:(0,t.jsx)(n.code,{children:"TokenInput"})})}),(0,t.jsx)(n.td,{children:"Token input configuration"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"limit"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/types#limitorderdata",children:(0,t.jsx)(n.code,{children:"LimitOrderData"})})}),(0,t.jsx)(n.td,{children:"Limit order configuration"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netLpOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"LP tokens received"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyFee"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Trading fees paid in SY"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyInterm"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"SY tokens generated from input token"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),"\nMost convenient method when you have any supported token and want to add liquidity. The function handles all necessary conversions and swaps automatically."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Simple Version Available"}),"\nFor basic operations without custom parameters, use ",(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/SimpleFunctions#addliquiditysingletokenSimple",children:(0,t.jsx)(n.code,{children:"addLiquiditySingleTokenSimple"})})," which automatically handles approximation and skips limit order functionality."]}),"\n",(0,t.jsx)(n.h3,{id:"addliquiditysinglesy",children:"addLiquiditySingleSy"}),"\n",(0,t.jsx)(n.p,{children:"Adds liquidity using only SY tokens by converting some to PT through market operations."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"function addLiquiditySingleSy(\n    address receiver,\n    address market,\n    uint256 netSyIn,\n    uint256 minLpOut,\n    ApproxParams calldata guessPtReceivedFromSy,\n    LimitOrderData calldata limit\n) external returns (uint256 netLpOut, uint256 netSyFee)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"receiver"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Address to receive LP tokens"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"market"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Pendle market address"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyIn"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Amount of SY tokens to use"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"minLpOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Minimum LP tokens to receive"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"guessPtReceivedFromSy"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/types#approxparams",children:(0,t.jsx)(n.code,{children:"ApproxParams"})})}),(0,t.jsx)(n.td,{children:"Approximation parameters"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"limit"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/types#limitorderdata",children:(0,t.jsx)(n.code,{children:"LimitOrderData"})})}),(0,t.jsx)(n.td,{children:"Limit order configuration"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netLpOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"LP tokens received"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyFee"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Trading fees paid in SY"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),"\nWhen you have SY tokens and want to add liquidity. The function will swap some SY for PT to achieve optimal liquidity provision."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Simple Version Available"}),"\nFor basic operations without custom parameters, use ",(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/SimpleFunctions#addliquiditysingleSySimple",children:(0,t.jsx)(n.code,{children:"addLiquiditySingleSySimple"})})," which automatically handles approximation and skips limit order functionality."]}),"\n",(0,t.jsx)(n.h3,{id:"addliquiditysingletokenkeepyt",children:"addLiquiditySingleTokenKeepYt"}),"\n",(0,t.jsx)(n.p,{children:"Adds liquidity while keeping the generated YT tokens instead of selling them."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"function addLiquiditySingleTokenKeepYt(\n    address receiver,\n    address market,\n    uint256 minLpOut,\n    uint256 minYtOut,\n    TokenInput calldata input\n) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"receiver"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Address to receive LP and YT tokens"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"market"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Pendle market address"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"minLpOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Minimum LP tokens to receive"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"minYtOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Minimum YT tokens to receive"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"input"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/types#tokeninput",children:(0,t.jsx)(n.code,{children:"TokenInput"})})}),(0,t.jsx)(n.td,{children:"Token input configuration"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netLpOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"LP tokens received"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netYtOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"YT tokens received"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyMintPy"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"SY used to mint PT/YT"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyInterm"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"SY tokens generated from input token"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),"\nWhen you want to add liquidity and also keep YT tokens for yield farming. This strategy avoids price impact since no swapping occurs - the underlying asset is converted to SY, then PT/YT pairs are minted directly. The PT and remaining SY are used for liquidity provision while YT is returned to you."]}),"\n",(0,t.jsx)(n.h3,{id:"addliquiditysinglesykeepyt",children:"addLiquiditySingleSyKeepYt"}),"\n",(0,t.jsx)(n.p,{children:"Adds liquidity using SY tokens while keeping the generated YT tokens."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"function addLiquiditySingleSyKeepYt(\n    address receiver,\n    address market,\n    uint256 netSyIn,\n    uint256 minLpOut,\n    uint256 minYtOut\n) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"receiver"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Address to receive LP and YT tokens"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"market"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Pendle market address"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyIn"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Amount of SY tokens to use"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"minLpOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Minimum LP tokens to receive"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"minYtOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Minimum YT tokens to receive"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netLpOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"LP tokens received"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netYtOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"YT tokens received"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyMintPy"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"SY used to mint PT/YT"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),"\nWhen you have SY tokens and want both LP tokens and YT tokens. This method avoids price impact since no swapping occurs - SY is used to mint PT/YT pairs directly, with PT used for liquidity provision and YT returned to you."]}),"\n",(0,t.jsx)(n.h2,{id:"remove-liquidity-functions",children:"Remove Liquidity Functions"}),"\n",(0,t.jsx)(n.h3,{id:"removeliquiditydualtokenandpt",children:"removeLiquidityDualTokenAndPt"}),"\n",(0,t.jsx)(n.p,{children:"Removes liquidity and receives both the underlying token and PT tokens."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"function removeLiquidityDualTokenAndPt(\n    address receiver,\n    address market,\n    uint256 netLpToRemove,\n    TokenOutput calldata output,\n    uint256 minPtOut\n) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"receiver"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Address to receive tokens"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"market"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Pendle market address"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netLpToRemove"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Amount of LP tokens to burn"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"output"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/types#tokenoutput",children:(0,t.jsx)(n.code,{children:"TokenOutput"})})}),(0,t.jsx)(n.td,{children:"Token output configuration"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"minPtOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Minimum PT tokens to receive"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netTokenOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Amount tokens received"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netPtOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"PT tokens received"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyInterm"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"SY tokens converted to underlying"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),"\nWhen you want to exit a liquidity position and receive both the underlying token and PT tokens separately."]}),"\n",(0,t.jsx)(n.h3,{id:"removeliquiditydualsyandpt",children:"removeLiquidityDualSyAndPt"}),"\n",(0,t.jsx)(n.p,{children:"Removes liquidity and receives both SY and PT tokens."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"function removeLiquidityDualSyAndPt(\n    address receiver,\n    address market,\n    uint256 netLpToRemove,\n    uint256 minSyOut,\n    uint256 minPtOut\n) external returns (uint256 netSyOut, uint256 netPtOut)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"receiver"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Address to receive tokens"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"market"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Pendle market address"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netLpToRemove"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Amount of LP tokens to burn"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"minSyOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Minimum SY tokens to receive"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"minPtOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Minimum PT tokens to receive"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"SY tokens received"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netPtOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"PT tokens received"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),"\nMost efficient method when you want both SY and PT tokens. No additional conversions are performed."]}),"\n",(0,t.jsx)(n.h3,{id:"removeliquiditysinglept",children:"removeLiquiditySinglePt"}),"\n",(0,t.jsx)(n.p,{children:"Removes liquidity and converts everything to PT tokens."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"function removeLiquiditySinglePt(\n    address receiver,\n    address market,\n    uint256 netLpToRemove,\n    uint256 minPtOut,\n    ApproxParams calldata guessPtReceivedFromSy,\n    LimitOrderData calldata limit\n) external returns (uint256 netPtOut, uint256 netSyFee)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"receiver"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Address to receive PT tokens"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"market"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Pendle market address"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netLpToRemove"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Amount of LP tokens to burn"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"minPtOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Minimum PT tokens to receive"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"guessPtReceivedFromSy"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/types#approxparams",children:(0,t.jsx)(n.code,{children:"ApproxParams"})})}),(0,t.jsx)(n.td,{children:"Approximation parameters"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"limit"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/types#limitorderdata",children:(0,t.jsx)(n.code,{children:"LimitOrderData"})})}),(0,t.jsx)(n.td,{children:"Limit order configuration"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netPtOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"PT tokens received"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyFee"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Trading fees paid in SY"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),"\nWhen you want to exit liquidity and hold only PT tokens, maximizing your PT position."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Simple Version Available"}),"\nFor basic operations without custom parameters, use ",(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/SimpleFunctions#removeliquiditysingleptSimple",children:(0,t.jsx)(n.code,{children:"removeLiquiditySinglePtSimple"})})," which automatically handles approximation and skips limit order functionality."]}),"\n",(0,t.jsx)(n.h3,{id:"removeliquiditysingletoken",children:"removeLiquiditySingleToken"}),"\n",(0,t.jsx)(n.p,{children:"Removes liquidity and converts everything to a specified underlying token."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"function removeLiquiditySingleToken(\n    address receiver,\n    address market,\n    uint256 netLpToRemove,\n    TokenOutput calldata output,\n    LimitOrderData calldata limit\n) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"receiver"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Address to receive tokens"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"market"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Pendle market address"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netLpToRemove"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Amount of LP tokens to burn"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"output"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/types#tokenoutput",children:(0,t.jsx)(n.code,{children:"TokenOutput"})})}),(0,t.jsx)(n.td,{children:"Token output configuration"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"limit"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/types#limitorderdata",children:(0,t.jsx)(n.code,{children:"LimitOrderData"})})}),(0,t.jsx)(n.td,{children:"Limit order configuration"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netTokenOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Amount tokens received"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyFee"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Trading fees paid in SY"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyInterm"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"SY tokens before conversion"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),"\nMost convenient exit method when you want to receive a specific underlying token. Handles all necessary conversions automatically."]}),"\n",(0,t.jsx)(n.h3,{id:"removeliquiditysinglesy",children:"removeLiquiditySingleSy"}),"\n",(0,t.jsx)(n.p,{children:"Removes liquidity and converts everything to SY tokens."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"function removeLiquiditySingleSy(\n    address receiver,\n    address market,\n    uint256 netLpToRemove,\n    uint256 minSyOut,\n    LimitOrderData calldata limit\n) external returns (uint256 netSyOut, uint256 netSyFee)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"receiver"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Address to receive SY tokens"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"market"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"address"})}),(0,t.jsx)(n.td,{children:"Pendle market address"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netLpToRemove"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Amount of LP tokens to burn"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"minSyOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Minimum SY tokens to receive"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"limit"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/types#limitorderdata",children:(0,t.jsx)(n.code,{children:"LimitOrderData"})})}),(0,t.jsx)(n.td,{children:"Limit order configuration"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyOut"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"SY tokens received"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"netSyFee"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint256"})}),(0,t.jsx)(n.td,{children:"Trading fees paid in SY"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),"\nWhen you want to exit liquidity and hold SY tokens, useful for further operations within the Pendle ecosystem."]}),"\n",(0,t.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,t.jsx)(n.h3,{id:"basic-liquidity-addition",children:"Basic Liquidity Addition"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"// Add liquidity with USDe\nrouter.addLiquiditySingleToken(\n    msg.sender,\n    PT_USDE_MARKET_ADDRESS,\n    minLpOut,\n    createDefaultApproxParams(),\n    createTokenInputSimple(USDE_ADDRESS, 1000e18),\n    createEmptyLimitOrderData()\n);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"basic-liquidity-removal",children:"Basic Liquidity Removal"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"// Remove liquidity to USDe\nrouter.removeLiquiditySingleToken(\n    msg.sender,\n    PT_USDE_MARKET_ADDRESS,\n    lpAmount,\n    createTokenOutputSimple(USDE_ADDRESS, minUsdeOut),\n    createEmptyLimitOrderData()\n);\n"})})]})}function a(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var d=i(6540);const t={},s=d.createContext(t);function r(e){const n=d.useContext(s);return d.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),d.createElement(s.Provider,{value:n},e.children)}}}]);