"use strict";(self.webpackChunkpendle_documentation=self.webpackChunkpendle_documentation||[]).push([[2070],{4306:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"Developers/Contracts/PendleRouter/ApiReference/PtFunctions","title":"Principal Token (PT) Trading Functions","description":"This document covers all functions for trading Principal Tokens (PT) in Pendle markets. PT tokens represent the principal portion of yield-bearing assets and can be traded against other tokens or SY tokens.","source":"@site/docs/pendle-v2/Developers/Contracts/PendleRouter/ApiReference/PtFunctions.md","sourceDirName":"Developers/Contracts/PendleRouter/ApiReference","slug":"/Developers/Contracts/PendleRouter/ApiReference/PtFunctions","permalink":"/pendle-v2/Developers/Contracts/PendleRouter/ApiReference/PtFunctions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_table_of_contents":true},"sidebar":"myAutogeneratedSidebar","previous":{"title":"Types and Utility Functions","permalink":"/pendle-v2/Developers/Contracts/PendleRouter/ApiReference/Types"},"next":{"title":"Yield Token (YT) Trading Functions","permalink":"/pendle-v2/Developers/Contracts/PendleRouter/ApiReference/YtFunctions"}}');var s=t(4848),i=t(8453);const d={hide_table_of_contents:!0},c="Principal Token (PT) Trading Functions",l={},a=[{value:"Token to PT Trading",id:"token-to-pt-trading",level:2},{value:"swapExactTokenForPt",id:"swapexacttokenforpt",level:3},{value:"swapExactSyForPt",id:"swapexactsyforpt",level:3},{value:"PT to Token Trading",id:"pt-to-token-trading",level:2},{value:"swapExactPtForToken",id:"swapexactptfortoken",level:3},{value:"swapExactPtForSy",id:"swapexactptforsy",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Buying PT-sUSDe with USDe",id:"buying-pt-susde-with-usde",level:3},{value:"Selling PT-sUSDe for USDe",id:"selling-pt-susde-for-usde",level:3},{value:"Direct SY to PT Trading",id:"direct-sy-to-pt-trading",level:3}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"principal-token-pt-trading-functions",children:"Principal Token (PT) Trading Functions"})}),"\n",(0,s.jsx)(n.p,{children:"This document covers all functions for trading Principal Tokens (PT) in Pendle markets. PT tokens represent the principal portion of yield-bearing assets and can be traded against other tokens or SY tokens."}),"\n",(0,s.jsx)(n.h2,{id:"token-to-pt-trading",children:"Token to PT Trading"}),"\n",(0,s.jsxs)(n.p,{children:["Since AMM only supports swaps by exact PT, to swap exact tokens for PT requires binary search approximation to find the correct amount of SY needed to achieve the desired PT output. For best usage, use the ",(0,s.jsx)(n.a,{href:"../../../Backend/HostedSdk#features",children:"SDK"})," for better approximation since running binary search on-chain is costly."]}),"\n",(0,s.jsx)(n.h3,{id:"swapexacttokenforpt",children:"swapExactTokenForPt"}),"\n",(0,s.jsx)(n.p,{children:"Swaps an exact amount of any supported token for PT tokens."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function swapExactTokenForPt(\n    address receiver,\n    address market,\n    uint256 minPtOut,\n    ApproxParams calldata guessPtOut,\n    TokenInput calldata input,\n    LimitOrderData calldata limit\n) external payable returns (uint256 netPtOut, uint256 netSyFee, uint256 netSyInterm)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"receiver"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address to receive PT tokens"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"market"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Pendle market address"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"minPtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Minimum PT tokens to receive"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"guessPtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"./Types#approxparams",children:(0,s.jsx)(n.code,{children:"ApproxParams"})})}),(0,s.jsx)(n.td,{children:"Approximation parameters"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"input"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"./Types#tokeninput",children:(0,s.jsx)(n.code,{children:"TokenInput"})})}),(0,s.jsx)(n.td,{children:"Token input configuration"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"limit"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"./Types#limitorderdata",children:(0,s.jsx)(n.code,{children:"LimitOrderData"})})}),(0,s.jsx)(n.td,{children:"Limit order configuration"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netPtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"PT tokens received"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFee"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Trading fees paid in SY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyInterm"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"SY tokens generated from input token"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Case"}),"\nMost common function for buying PT tokens with any supported token. The function converts your token to SY and then swaps SY for PT, first filling available limit orders, then using the AMM for any remaining amount."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Simple Version Available"}),"\nFor basic operations without custom parameters, use ",(0,s.jsx)(n.a,{href:"./SimpleFunctions#swapexacttokenforptsimple",children:(0,s.jsx)(n.code,{children:"swapExactTokenForPtSimple"})})," which automatically handles approximation and skips limit order functionality."]}),"\n",(0,s.jsx)(n.h3,{id:"swapexactsyforpt",children:"swapExactSyForPt"}),"\n",(0,s.jsx)(n.p,{children:"Swaps an exact amount of SY tokens for PT tokens."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function swapExactSyForPt(\n    address receiver,\n    address market,\n    uint256 exactSyIn,\n    uint256 minPtOut,\n    ApproxParams calldata guessPtOut,\n    LimitOrderData calldata limit\n) external returns (uint256 netPtOut, uint256 netSyFee)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"receiver"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address to receive PT tokens"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"market"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Pendle market address"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"exactSyIn"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Exact amount of SY tokens to swap"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"minPtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Minimum PT tokens to receive"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"guessPtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"./Types#approxparams",children:(0,s.jsx)(n.code,{children:"ApproxParams"})})}),(0,s.jsx)(n.td,{children:"Approximation parameters"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"limit"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"./Types#limitorderdata",children:(0,s.jsx)(n.code,{children:"LimitOrderData"})})}),(0,s.jsx)(n.td,{children:"Limit order configuration"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netPtOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"PT tokens received"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFee"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Trading fees paid in SY"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Case"}),"\nDirect and efficient method when you already have SY tokens and want to buy PT tokens."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Simple Version Available"}),"\nFor basic operations without custom parameters, use ",(0,s.jsx)(n.a,{href:"./SimpleFunctions#swapexactsyforptsimple",children:(0,s.jsx)(n.code,{children:"swapExactSyForPtSimple"})})," which automatically handles approximation and skips limit order functionality."]}),"\n",(0,s.jsx)(n.h2,{id:"pt-to-token-trading",children:"PT to Token Trading"}),"\n",(0,s.jsx)(n.h3,{id:"swapexactptfortoken",children:"swapExactPtForToken"}),"\n",(0,s.jsx)(n.p,{children:"Swaps an exact amount of PT tokens for any supported token."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function swapExactPtForToken(\n    address receiver,\n    address market,\n    uint256 exactPtIn,\n    TokenOutput calldata output,\n    LimitOrderData calldata limit\n) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"receiver"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address to receive tokens"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"market"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Pendle market address"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"exactPtIn"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Exact amount of PT tokens to swap"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"output"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"./Types#tokenoutput",children:(0,s.jsx)(n.code,{children:"TokenOutput"})})}),(0,s.jsx)(n.td,{children:"Token output configuration"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"limit"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"./Types#limitorderdata",children:(0,s.jsx)(n.code,{children:"LimitOrderData"})})}),(0,s.jsx)(n.td,{children:"Limit order configuration"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netTokenOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Amount tokens received"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFee"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Trading fees paid in SY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyInterm"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"SY tokens before conversion"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Case"}),"\nMost common function for selling PT tokens to receive tokens. The function swaps PT for SY (first filling available limit orders, then using the AMM), then converts SY to your desired token."]}),"\n",(0,s.jsx)(n.h3,{id:"swapexactptforsy",children:"swapExactPtForSy"}),"\n",(0,s.jsx)(n.p,{children:"Swaps an exact amount of PT tokens for SY tokens."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function swapExactPtForSy(\n    address receiver,\n    address market,\n    uint256 exactPtIn,\n    uint256 minSyOut,\n    LimitOrderData calldata limit\n) external returns (uint256 netSyOut, uint256 netSyFee)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"receiver"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address to receive SY tokens"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"market"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Pendle market address"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"exactPtIn"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Exact amount of PT tokens to swap"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"minSyOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Minimum SY tokens to receive"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"limit"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"./Types#limitorderdata",children:(0,s.jsx)(n.code,{children:"LimitOrderData"})})}),(0,s.jsx)(n.td,{children:"Limit order configuration"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"SY tokens received"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFee"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Trading fees paid in SY"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Case"}),"\nDirect and efficient method for selling PT tokens to receive SY tokens."]}),"\n",(0,s.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,s.jsx)(n.h3,{id:"buying-pt-susde-with-usde",children:"Buying PT-sUSDe with USDe"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// Swap 1000 USDe for PT-sUSDe tokens\nrouter.swapExactTokenForPt(\n    msg.sender,\n    PT_SUSDE_MARKET_ADDRESS,\n    minPtOut,\n    createDefaultApproxParams(),\n    createTokenInputSimple(USDE_ADDRESS, 1000e18),\n    createEmptyLimitOrderData()\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"selling-pt-susde-for-usde",children:"Selling PT-sUSDe for USDe"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// Swap PT-sUSDe tokens for USDe\nrouter.swapExactPtForToken(\n    msg.sender,\n    PT_SUSDE_MARKET_ADDRESS,\n    ptAmount,\n    createTokenOutputSimple(USDE_ADDRESS, minUsdeOut),\n    createEmptyLimitOrderData()\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"direct-sy-to-pt-trading",children:"Direct SY to PT Trading"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// Swap SY tokens directly for PT tokens\nrouter.swapExactSyForPt(\n    msg.sender,\n    MARKET_ADDRESS,\n    syAmount,\n    minPtOut,\n    createDefaultApproxParams(),\n    createEmptyLimitOrderData()\n);\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>c});var r=t(6540);const s={},i=r.createContext(s);function d(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);