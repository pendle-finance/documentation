"use strict";(self.webpackChunkpendle_documentation=self.webpackChunkpendle_documentation||[]).push([[234],{17834:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"Contracts/MarketHub","title":"MarketHub View Functions","description":"getEnteredMarkets()","source":"@site/docs/boros/Contracts/MarketHub.md","sourceDirName":"Contracts","slug":"/Contracts/MarketHub","permalink":"/boros/Contracts/MarketHub","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"borosSidebar","previous":{"title":"Router","permalink":"/boros/Contracts/Router"},"next":{"title":"Market","permalink":"/boros/Contracts/Market"}}');var s=n(74848),r=n(28453);const o={},i="MarketHub View Functions",d={},c=[{value:"<code>getEnteredMarkets()</code>",id:"getenteredmarkets",level:3},{value:"<code>hasEnteredMarketBefore()</code>",id:"hasenteredmarketbefore",level:3},{value:"<code>tokenIdToAddress()</code>",id:"tokenidtoaddress",level:3},{value:"<code>marketIdToAddress()</code>",id:"marketidtoaddress",level:3},{value:"<code>tokenData()</code>",id:"tokendata",level:3},{value:"Cash and Balance Functions",id:"cash-and-balance-functions",level:2},{value:"<code>accCash()</code>",id:"acccash",level:3},{value:"<code>getCashFeeData()</code>",id:"getcashfeedata",level:3},{value:"<code>getUserWithdrawalStatus()</code>",id:"getuserwithdrawalstatus",level:3},{value:"<code>settleAllAndGet()</code>",id:"settleallandget",level:3},{value:"<code>simulateTransfer()</code>",id:"simulatetransfer",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"markethub-view-functions",children:"MarketHub View Functions"})}),"\n",(0,s.jsx)(t.h3,{id:"getenteredmarkets",children:(0,s.jsx)(t.code,{children:"getEnteredMarkets()"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"MarketAcc userAccount = AccountLib.toMainCross(userAddress, tokenId);\nMarketId[] memory markets = marketHub.getEnteredMarkets(userAccount);\n"})}),"\n",(0,s.jsx)(t.h3,{id:"hasenteredmarketbefore",children:(0,s.jsx)(t.code,{children:"hasEnteredMarketBefore()"})}),"\n",(0,s.jsx)(t.p,{children:"Returns whether the account has entered the specified market before. This is used to determine if the account needs to pay a market entrance fee. When entering a market for the first time, users pay a one-time entrance fee that goes to the protocol treasury. Subsequent entries to the same market don't incur this fee."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"MarketAcc userAccount = AccountLib.toCross(userAddress, tokenId);\nMarketId marketId = MarketId.wrap(2);\n\nbool hasEnteredBefore = marketHub.hasEnteredMarketBefore(userAccount, marketId);\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tokenidtoaddress",children:(0,s.jsx)(t.code,{children:"tokenIdToAddress()"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"TokenId btcTokenId = TokenId.wrap(1);\naddress btcAddress = marketHub.tokenIdToAddress(btcTokenId);\n"})}),"\n",(0,s.jsx)(t.h3,{id:"marketidtoaddress",children:(0,s.jsx)(t.code,{children:"marketIdToAddress()"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"MarketId btcMarketId = MarketId.wrap(456);\naddress btcMarketAddress = marketHub.marketIdToAddress(marketId);\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tokendata",children:(0,s.jsx)(t.code,{children:"tokenData()"})}),"\n",(0,s.jsxs)(t.p,{children:["Returns the token configuration data for the specified token ID. The ",(0,s.jsx)(t.code,{children:"TokenData"})," struct contains:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"token"}),": The ERC20 token contract address"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"scalingFactor"}),": Used to normalize token decimals to 18-decimal precision for internal calculations. Calculated as ",(0,s.jsx)(t.code,{children:"10^(18 - tokenDecimals)"})," during token registration"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"TokenId btcTokenId = TokenId.wrap(1);\nTokenData memory data = marketHub.tokenData(tokenId);\n"})}),"\n",(0,s.jsx)(t.h2,{id:"cash-and-balance-functions",children:"Cash and Balance Functions"}),"\n",(0,s.jsx)(t.h3,{id:"acccash",children:(0,s.jsx)(t.code,{children:"accCash()"})}),"\n",(0,s.jsx)(t.p,{children:"Returns the account's cash balance in scaled units. The cash balance can be negative, which represents upfront borrowing (borrowed funds that need to be repaid)."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Important caveats:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Similar to ",(0,s.jsx)(t.code,{children:"NoSettle"})," functions in Market contracts, this returns unsettled data that may be outdated"]}),"\n",(0,s.jsxs)(t.li,{children:["Due to Boros's ",(0,s.jsx)(t.a,{href:"/boros/Mechanics/Settlement",children:"lazy settlement"})," mechanism, positions and cash balances are only updated when users interact with the protocol"]}),"\n",(0,s.jsxs)(t.li,{children:["To get up-to-date cash balance, you must settle first using ",(0,s.jsx)(t.code,{children:"settleAllAndGet()"})," or trigger settlement through other interactions"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"// Check cross-margin cash balance\nMarketAcc crossAccount = AccountLib.toMainCross(userAddress, tokenId);\nint256 crossCash = marketHub.accCash(crossAccount);\n"})}),"\n",(0,s.jsx)(t.h3,{id:"getcashfeedata",children:(0,s.jsx)(t.code,{children:"getCashFeeData()"})}),"\n",(0,s.jsx)(t.p,{children:"Returns fee configuration and treasury data for the specified token."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"TokenId tokenId = TokenId.wrap(1);\nCashFeeData memory feeData = marketHub.getCashFeeData(tokenId);\n\nuint128 treasuryCash = feeData.treasuryCash;          // Protocol treasury balance\nuint128 entranceFee = feeData.marketEntranceFee;      // Fee to enter markets\nuint128 minCashCross = feeData.minCashCross;          // Min cash for cross-margin\nuint128 minCashIsolated = feeData.minCashIsolated;    // Min cash for isolated\n"})}),"\n",(0,s.jsx)(t.h3,{id:"getuserwithdrawalstatus",children:(0,s.jsx)(t.code,{children:"getUserWithdrawalStatus()"})}),"\n",(0,s.jsx)(t.p,{children:"Returns the user's pending withdrawal status."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Important caveats:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.code,{children:"amount"})," field (",(0,s.jsx)(t.code,{children:"unscaled"}),") is in the token's native decimal precision, not Boros's internal 18-decimal scaling"]}),"\n",(0,s.jsxs)(t.li,{children:["To finalize the withdrawal, the condition ",(0,s.jsx)(t.code,{children:"start + cooldown <= block.timestamp"})," must be satisfied"]}),"\n",(0,s.jsx)(t.li,{children:"Cash is deducted immediately when withdrawal is requested, but tokens are only transferred after the cooldown period"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:'address userAddress = 0x123...;\nTokenId tokenId = TokenId.wrap(1);\n\nWithdrawal memory withdrawal = marketHub.getUserWithdrawalStatus(userAddress, tokenId);\n\nuint32 startTime = withdrawal.start;      // Withdrawal request timestamp\nuint224 amount = withdrawal.unscaled;     // Unscaled withdrawal amount\n\nif (amount) {\n    uint32 cooldown = marketHub.getPersonalCooldown(userAddress);\n    uint32 finalizationTime = startTime + cooldown;\n\n    if (block.timestamp >= finalizationTime) {\n        console.log("Withdrawal ready for finalization");\n        console.log("Amount: %s", amount);\n    } else {\n        uint32 remaining = finalizationTime - uint32(block.timestamp);\n        console.log("Withdrawal pending, %s seconds remaining", remaining);\n    }\n} else {\n    console.log("No pending withdrawal");\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"settleallandget",children:(0,s.jsx)(t.code,{children:"settleAllAndGet()"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:'MarketAcc userAccount = AccountLib.toMainCross(userAddress, tokenId);\nMarketId marketId = MarketId.wrap(123);\n\n// Get all settlement data and margin requirements\n(\n    int256 totalCash,\n    VMResult totalMarginData,\n) = marketHub.settleAllAndGet(userAccount, GetRequest.MM, MarketIdLib.ZERO);\n\n// Parse margin data\n(int256 totalPositionValue, uint256 totalMaintenanceMargin) = totalMarginData.unpack();\n\nconsole.log("Total value: %s", totalCash + totalPositionValue);\nconsole.log("Total Maintenance Margin: %s", totalMaintenanceMargin);\n\n// Calculate health ratio\nint256 healthRatio = (totalCash + totalPositionValue) * 1e18 / int256(marginRequired);\nconsole.log("Health ratio: %s", healthRatio);\n'})}),"\n",(0,s.jsx)(t.h3,{id:"simulatetransfer",children:(0,s.jsx)(t.code,{children:"simulateTransfer()"})}),"\n",(0,s.jsx)(t.p,{children:"Used for off-chain simulation only. This function allows simulating cash transfers to test scenarios like margin requirements or health ratios without affecting the actual blockchain state."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Requirement:"})," This function can only be executed when faking ",(0,s.jsx)(t.code,{children:"tx.origin = address(0)"})," (using ",(0,s.jsx)(t.code,{children:"eth_call"})," state overrides)."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"MarketAcc fromAccount = AccountLib.toMainCross(userAddress, tokenId);\nint256 transferAmount = 1 ether;\n\nmarketHub.simulateTransfer(fromAccount, transferAmount);\n"})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var a=n(96540);const s={},r=a.createContext(s);function o(e){const t=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);