"use strict";(self.webpackChunkpendle_documentation=self.webpackChunkpendle_documentation||[]).push([[8542],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,h=u["".concat(s,".").concat(m)]||u[m]||c[m]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9785:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={hide_table_of_contents:!0},o="PendleRouter",l={unversionedId:"Developers/Contracts/PendleRouter",id:"Developers/Contracts/PendleRouter",title:"PendleRouter",description:"Overview",source:"@site/docs/Developers/Contracts/PendleRouter.md",sourceDirName:"Developers/Contracts",slug:"/Developers/Contracts/PendleRouter",permalink:"/cn/Developers/Contracts/PendleRouter",draft:!1,tags:[],version:"current",frontMatter:{hide_table_of_contents:!0},sidebar:"myAutogeneratedSidebar",previous:{title:"High Level Architecture",permalink:"/cn/Developers/HighLevelArchitecture"},next:{title:"vePENDLE",permalink:"/cn/Developers/Contracts/vePENDLE"}},s={},p=[{value:"Overview",id:"overview",level:2},{value:"Off-chain helpers",id:"off-chain-helpers",level:2},{value:"Common Functions",id:"common-functions",level:2},{value:"Add/Remove Liquidity",id:"addremove-liquidity",level:3},{value:"Buy/Sell PT, YT",id:"buysell-pt-yt",level:3},{value:"Redeeming PT post-expiry for the underlying",id:"redeeming-pt-post-expiry-for-the-underlying",level:3},{value:"Redeeming LP, YT yield",id:"redeeming-lp-yt-yield",level:3},{value:"Important Structures in PendleRouter",id:"important-structures-in-pendlerouter",level:2},{value:"ApproxParams",id:"approxparams",level:3},{value:"TokenInput",id:"tokeninput",level:2},{value:"TokenOutput",id:"tokenoutput",level:3}],d={toc:p},u="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"pendlerouter"},"PendleRouter"),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"PendleRouter is a contract that aggregates callers' actions with various different SYs, PTs, YTs, and Markets. It is not owned, immutable, and does not have any special permissions or whitelists on any contracts it interacts with. For this reason, any third-party protocols can freely embed the router's logic into their code for better gas efficiency."),(0,r.kt)("p",null,"The Router is also a ",(0,r.kt)("strong",{parentName:"p"},"static")," Diamond-Proxy (ERC2535) contract without any upgrade functions as described in this ",(0,r.kt)("a",{parentName:"p",href:"https://twitter.com/mudgen/status/1630229952523272195/"},"tweet"),". A summary for ERC2535 is that there can be multiple implementation contracts for a single proxy, with each function (or set of functions) delegatecall to its own implementation."),(0,r.kt)("p",null,"To interact easily with the PendleRouter, please refer to: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/pendle-finance/pendle-core-v2-public/blob/main/contracts/interfaces/IPAllActionV3.sol"},"https://github.com/pendle-finance/pendle-core-v2-public/blob/main/contracts/interfaces/IPAllActionV3.sol")),(0,r.kt)("p",null,"For a list of all the functions that can be called on the Router, users can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"IPAllActionV3 ABI")," and call it on the Router address, which will resolve the call accordingly."),(0,r.kt)("h2",{id:"off-chain-helpers"},"Off-chain helpers"),(0,r.kt)("p",null,"PendleRouter heavily relies on off-chain data to address two main issues:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Currently, Pendle's AMM only supports the built-in ",(0,r.kt)("inlineCode",{parentName:"li"},"swapExactPtForSy")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"swapSyForExactPt"),". To execute a ",(0,r.kt)("inlineCode",{parentName:"li"},"swapExactTokenForPt")," (which is essentially the same as ",(0,r.kt)("inlineCode",{parentName:"li"},"swapExactSyForPt"),"), the router will conduct a binary search to determine the amount of PT to swap. This number will then be used to perform a ",(0,r.kt)("inlineCode",{parentName:"li"},"swapSyForExactPt")," instead. While the binary search can be done entirely on-chain, limiting the search range off-chain will result in significantly less gas consumption for this function."),(0,r.kt)("li",{parentName:"ul"},"Liquidity is currently fragmented across a large number of pools across various DEXes, leading to fragmentation of DEXes. Integrating only Uniswap or Balancer has proven to be insufficient. As a result, PendleRouter has natively integrated ",(0,r.kt)("a",{parentName:"li",href:"https://kyberswap.com/"},"KyberSwap")," to swap from any ERC20 token to another. For Kyberswap to work, the routing algorithm must be called off-chain then pass the routing results to the Router to execute.")),(0,r.kt)("h2",{id:"common-functions"},"Common Functions"),(0,r.kt)("p",null,"Please see ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/pendle-finance/pendle-core-v2-public/blob/main/contracts/interfaces/IPAllActionV3.sol"},"IPAllActionV3")," for a complete list of features."),(0,r.kt)("h3",{id:"addremove-liquidity"},"Add/Remove Liquidity"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"addLiquiditySingleToken"),": Add liquidity to a market with any ERC20 tokens."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"removeLiquiditySingleToken"),": Remove liquidity from a market with ERC20 tokens."),(0,r.kt)("h3",{id:"buysell-pt-yt"},"Buy/Sell PT, YT"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"swapExactTokenForPt"),": Swap an exact amount of a supported ERC20 token for PT."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"swapExactPtForToken"),": Swap an exact amount of PT for a supported ERC20 token."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"swapExactTokenForYt"),": Swap an exact amount of a supported ERC20 token for TT."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"swapExactYtForToken"),": Swap an exact amount of YT for a supported ERC20 token."),(0,r.kt)("h3",{id:"redeeming-pt-post-expiry-for-the-underlying"},"Redeeming PT post-expiry for the underlying"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"RedeemPyToToken"),": PY stands for PT and YT. However, you no longer need YT post-expiry to redeem."),(0,r.kt)("h3",{id:"redeeming-lp-yt-yield"},"Redeeming LP, YT yield"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"redeemDueInterestAndRewards"),": Redeem the accrued interest and rewards from both the LP position and YT."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"We highly recommend using Pendle's SDK to generate calldata. The guide to use Pendle\u2019s SDK can be found ",(0,r.kt)("a",{parentName:"p",href:"/cn/Developers/Helpers/HostedSDK"},"here"),".")),(0,r.kt)("p",null,"However, if you prefer to generate the data without using the Pendle SDK, the below sections should be relevant."),(0,r.kt)("h2",{id:"important-structures-in-pendlerouter"},"Important Structures in PendleRouter"),(0,r.kt)("p",null,"While most function arguments should be straightforward, using structs can be less intuitive. PendleRouter is a sophisticated contract that supports various powerful features and relies on off-chain pre-computed data to help save gas. Below are the important structs and instructions on how to fill them:"),(0,r.kt)("h3",{id:"approxparams"},"ApproxParams"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The easiest way to generate this struct is to use Pendle's SDK. If you want to understand more, keep reading!")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"struct ApproxParams {\n    uint256 guessMin;\n    uint256 guessMax;\n    uint256 guessOffchain;\n    uint256 maxIteration;\n    uint256 eps;\n}\n")),(0,r.kt)("p",null,"In this structure, the following parameters are defined:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"guessMin")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"guessMax"),": The minimum and maximum values for binary search."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"maxIteration"),": The maximum number of times binary search will be performed."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"eps"),": The precision of binary search - the ",(0,r.kt)("strong",{parentName:"li"},"maximum")," proportion of the input that can be unused. ",(0,r.kt)("inlineCode",{parentName:"li"},"eps")," is 1e18-based, so an ",(0,r.kt)("inlineCode",{parentName:"li"},"eps")," of 1e14 implies that no more than 0.01% of the input might be unused."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"guessOffchain"),": This is the first answer to be checked before performing any binary search. If the answer already satisfies, we skip the search and save significant gas.")),(0,r.kt)("p",null,"In case off-chain data cannot be provided, the parameters can be passed as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"guessMin: 0, // adjust as desired\nguessMax: type(uint256).max, // adjust as desired\nguessOffchain: 0, // strictly 0\nmaxIteration: 256, // adjust as desired\neps: 1e15 // max 0.1% unused, adjust as desired\n")),(0,r.kt)("p",null,"Please note that in this situation, the parameters can be fine-tuned to narrow the search range for optimal gas usage or to reduce the number of unused inputs."),(0,r.kt)("h2",{id:"tokeninput"},"TokenInput"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"struct TokenInput {\n    // token/Sy data\n    address tokenIn;\n    uint256 netTokenIn;\n    address tokenMintSy;\n    address bulk;\n    // aggregator data\n    address pendleSwap;\n    SwapData swapData;\n}\n\nstruct SwapData {\n    SwapType swapType;\n    address extRouter;\n    bytes extCalldata;\n    bool needScale;\n}\n\nenum SwapType {\n    NONE,\n    KYBERSWAP,\n    ONE_INCH,\n    // ETH_WETH not used in Aggregator\n    ETH_WETH\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"tokenIn")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"netTokenIn")," refer to the token used for swapping or adding liquidity."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"tokenMintSy")," is the token that ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenIn")," will be swapped to in order to mint SY. For example, if ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenIn")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"USDC")," but users are adding liquidity to the stETH market, then ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenMintSy")," must be ETH, and ",(0,r.kt)("inlineCode",{parentName:"p"},"pendleSwap")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"swapData")," must be populated."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"bulk")," should be passed as ",(0,r.kt)("inlineCode",{parentName:"p"},"address(0)"),"."),(0,r.kt)("p",null,"For ",(0,r.kt)("inlineCode",{parentName:"p"},"pendleSwap")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"swapData"),", by default, all values will be zero unless ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenIn")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenMintSy")," are different from each other. In this case, the following should be passed:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pendleSwap"),": Address of the ",(0,r.kt)("inlineCode",{parentName:"li"},"pendleSwap")," deployment on that chain. This was not hardcoded to allow for easy upgrade of ",(0,r.kt)("inlineCode",{parentName:"li"},"pendleSwap"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"swapData"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"swapType"),": Usually ",(0,r.kt)("inlineCode",{parentName:"li"},"KYBERSWAP"),", unless it's a simple ETH wrap-unwrap, in which case ",(0,r.kt)("inlineCode",{parentName:"li"},"ETH_WETH")," should be used."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"extRouter"),": If ",(0,r.kt)("inlineCode",{parentName:"li"},"KYBERSWAP")," is chosen, this will be passed as their router address."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"extCalldata"),": If ",(0,r.kt)("inlineCode",{parentName:"li"},"KYBERSWAP")," is chosen, this will be passed as the calldata returned by their routing API."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"needScale"),": If ",(0,r.kt)("inlineCode",{parentName:"li"},"KYBERSWAP")," is chosen, we will pass false if the ",(0,r.kt)("inlineCode",{parentName:"li"},"amountIn")," used to generate calldata and ",(0,r.kt)("inlineCode",{parentName:"li"},"netTokenIn")," are the same. Otherwise, pass true.")))),(0,r.kt)("p",null,"Please note that all of KyberSwap's related API can be obtained from ",(0,r.kt)("a",{parentName:"p",href:"https://docs.kyberswap.com/"},"Kyberswap's own API"),"."),(0,r.kt)("h3",{id:"tokenoutput"},"TokenOutput"),(0,r.kt)("p",null,"Same as TokenOutput."))}c.isMDXComponent=!0}}]);