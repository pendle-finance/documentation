"use strict";(self.webpackChunkpendle_documentation=self.webpackChunkpendle_documentation||[]).push([[478],{8453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>l});var r=t(6540);const s={},i=r.createContext(s);function d(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),r.createElement(i.Provider,{value:n},e.children)}},9927:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"Developers/Contracts/PendleRouter/ApiReference/Types","title":"Types and Utility Functions","description":"This document covers all struct types used throughout the Pendle Router and utility functions for generating parameters on-chain.","source":"@site/docs/pendle-v2/Developers/Contracts/PendleRouter/ApiReference/Types.md","sourceDirName":"Developers/Contracts/PendleRouter/ApiReference","slug":"/Developers/Contracts/PendleRouter/ApiReference/Types","permalink":"/cn/pendle-v2/Developers/Contracts/PendleRouter/ApiReference/Types","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_table_of_contents":true},"sidebar":"myAutogeneratedSidebar","previous":{"title":"Pendle Router Contract Integration Guide","permalink":"/cn/pendle-v2/Developers/Contracts/PendleRouter/ContractIntegrationGuide"},"next":{"title":"Principal Token (PT) Trading Functions","permalink":"/cn/pendle-v2/Developers/Contracts/PendleRouter/ApiReference/PtFunctions"}}');var s=t(4848),i=t(8453);const d={hide_table_of_contents:!0},l="Types and Utility Functions",c={},o=[{value:"Core Parameter Types",id:"core-parameter-types",level:2},{value:"TokenInput",id:"tokeninput",level:3},{value:"Usage Patterns",id:"usage-patterns",level:3},{value:"TokenOutput",id:"tokenoutput",level:3},{value:"Usage Patterns",id:"usage-patterns-1",level:3},{value:"ApproxParams",id:"approxparams",level:3},{value:"LimitOrderData",id:"limitorderdata",level:3},{value:"RedeemYtIncomeToTokenStruct",id:"redeemytincometotokenstruct",level:3},{value:"SwapData",id:"swapdata",level:3},{value:"SwapType",id:"swaptype",level:3},{value:"ExitPreExpReturnParams",id:"exitpreexpreturnparams",level:3},{value:"ExitPostExpReturnParams",id:"exitpostexpreturnparams",level:3},{value:"Utility Functions",id:"utility-functions",level:2},{value:"createTokenInputSimple",id:"createtokeninputsimple",level:3},{value:"createTokenOutputSimple",id:"createtokenoutputsimple",level:3},{value:"createDefaultApproxParams",id:"createdefaultapproxparams",level:3},{value:"createEmptyLimitOrderData",id:"createemptylimitorderdata",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Basic Parameter Creation",id:"basic-parameter-creation",level:3},{value:"Complete Function Call Example",id:"complete-function-call-example",level:3},{value:"Custom ApproxParams for Advanced Use",id:"custom-approxparams-for-advanced-use",level:3},{value:"Best Practices",id:"best-practices",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"types-and-utility-functions",children:"Types and Utility Functions"})}),"\n",(0,s.jsx)(n.p,{children:"This document covers all struct types used throughout the Pendle Router and utility functions for generating parameters on-chain."}),"\n",(0,s.jsx)(n.h2,{id:"core-parameter-types",children:"Core Parameter Types"}),"\n",(0,s.jsx)(n.h3,{id:"tokeninput",children:"TokenInput"}),"\n",(0,s.jsx)(n.p,{children:"Defines input token configuration for functions that accept tokens."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"struct TokenInput {\n    address tokenIn;\n    uint256 netTokenIn;\n    address tokenMintSy;\n    address pendleSwap;\n    SwapData swapData;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fields"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"tokenIn"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address of the input token (can be any ERC20 token supported by Pendle)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netTokenIn"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Amount of input tokens"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"tokenMintSy"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Token used to mint SY (must be supported by target SY contract)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"pendleSwap"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsxs)(n.td,{children:["Swap aggregator address (use ",(0,s.jsx)(n.code,{children:"address(0)"})," for direct SY token input)"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"swapData"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"SwapData"})}),(0,s.jsx)(n.td,{children:"Swap configuration data for external aggregation"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"usage-patterns",children:"Usage Patterns"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Direct SY Token Input (Simple):"}),"\nWhen ",(0,s.jsx)(n.code,{children:"tokenIn"})," is already a token supported by the target SY contract:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Set ",(0,s.jsx)(n.code,{children:"tokenIn = tokenMintSy"})," (same token)"]}),"\n",(0,s.jsxs)(n.li,{children:["Set ",(0,s.jsx)(n.code,{children:"pendleSwap = address(0)"})," (no external swap needed)"]}),"\n",(0,s.jsxs)(n.li,{children:["Set ",(0,s.jsx)(n.code,{children:"swapData"})," to empty (no aggregation)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Any ERC20 Token Input (Zap In):"}),"\nWhen ",(0,s.jsx)(n.code,{children:"tokenIn"})," is any ERC20 token that needs to be swapped to a supported SY token:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Set ",(0,s.jsx)(n.code,{children:"tokenIn"})," to the user's input token (e.g., USDC, DAI, WETH)"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Set ",(0,s.jsx)(n.code,{children:"tokenMintSy"})," to a token supported by the target SY"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Set ",(0,s.jsx)(n.code,{children:"pendleSwap"})," to the swap aggregator address"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Set ",(0,s.jsx)(n.code,{children:"swapData"})," with proper aggregator configuration."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"E.g"}),": When you had USDC token and want to mint SY-sUSDe:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Set ",(0,s.jsx)(n.code,{children:"tokenIn = USDC"})]}),"\n",(0,s.jsxs)(n.li,{children:["Set ",(0,s.jsx)(n.code,{children:"tokenMintSy = SY-sUSDe"})]}),"\n",(0,s.jsxs)(n.li,{children:["Set ",(0,s.jsx)(n.code,{children:"pendleSwap = 0xd4F480965D2347d421F1bEC7F545682E5Ec2151D"})]}),"\n",(0,s.jsxs)(n.li,{children:["Set ",(0,s.jsx)(n.code,{children:"swapData"})," to proper data configuration obtained from ",(0,s.jsx)(n.a,{href:"/Developers/Backend/BackendAndHostedSDK#supported-functions",children:"SDK"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Benefits of Zap In:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Users can interact with any Pendle market using any ERC20 token they hold"}),"\n",(0,s.jsx)(n.li,{children:"No need to manually swap tokens before interacting with Pendle"}),"\n",(0,s.jsx)(n.li,{children:"Optimal routing through multiple DEXes for best price execution"}),"\n",(0,s.jsx)(n.li,{children:"Single transaction for swap + Pendle operation"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"SDK Integration:"}),"\nThe ",(0,s.jsx)(n.a,{href:"/Developers/Backend/BackendAndHostedSDK#features",children:"Pendle Hosted SDK"})," automatically handles all TokenInput configuration when you enable routing. When you set ",(0,s.jsx)(n.code,{children:"enableAggregator: true"})," in SDK calls, it:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Automatically selects the best swap aggregator (KyberSwap, ODOS, 1inch, etc.)"}),"\n",(0,s.jsxs)(n.li,{children:["Generates optimal ",(0,s.jsx)(n.code,{children:"swapData"})," for the chosen route"]}),"\n",(0,s.jsx)(n.li,{children:"Handles all token conversions transparently"}),"\n",(0,s.jsx)(n.li,{children:"Provides the best possible price execution across multiple DEXes"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For direct contract interaction, you need to manually configure these fields or use utility functions like ",(0,s.jsx)(n.code,{children:"createTokenInputSimple()"})," for basic operations."]}),"\n",(0,s.jsx)(n.h3,{id:"tokenoutput",children:"TokenOutput"}),"\n",(0,s.jsx)(n.p,{children:"Defines output token configuration for functions that return tokens."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"struct TokenOutput {\n    address tokenOut;\n    uint256 minTokenOut;\n    address tokenRedeemSy;\n    address pendleSwap;\n    SwapData swapData;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fields"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"tokenOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address of the desired output token (can be any ERC20 token supported by Pendle)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"minTokenOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Minimum amount of output tokens to receive (slippage protection)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"tokenRedeemSy"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Token to redeem SY to (must be supported by target SY contract)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"pendleSwap"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsxs)(n.td,{children:["Swap aggregator address (use ",(0,s.jsx)(n.code,{children:"address(0)"})," for direct SY token output)"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"swapData"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"SwapData"})}),(0,s.jsx)(n.td,{children:"Swap configuration data for external aggregation"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"usage-patterns-1",children:"Usage Patterns"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Direct SY Token Output (Simple):"}),"\nWhen ",(0,s.jsx)(n.code,{children:"tokenOut"})," is already a token supported by the target SY contract:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Set ",(0,s.jsx)(n.code,{children:"tokenOut = tokenRedeemSy"})," (same token)"]}),"\n",(0,s.jsxs)(n.li,{children:["Set ",(0,s.jsx)(n.code,{children:"pendleSwap = address(0)"})," (no external swap needed)"]}),"\n",(0,s.jsxs)(n.li,{children:["Set ",(0,s.jsx)(n.code,{children:"swapData"})," to empty (no aggregation)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Any ERC20 Token Output (Zap Out):"}),"\nWhen ",(0,s.jsx)(n.code,{children:"tokenOut"})," is any ERC20 token different from supported SY tokens:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Set ",(0,s.jsx)(n.code,{children:"tokenOut"})," to the user's desired token (e.g., USDC, DAI, WETH)"]}),"\n",(0,s.jsxs)(n.li,{children:["Set ",(0,s.jsx)(n.code,{children:"tokenRedeemSy"})," to a token supported by the target SY"]}),"\n",(0,s.jsxs)(n.li,{children:["Set ",(0,s.jsx)(n.code,{children:"pendleSwap"})," to the swap aggregator address"]}),"\n",(0,s.jsxs)(n.li,{children:["Set ",(0,s.jsx)(n.code,{children:"swapData"})," with proper aggregator configuration (KyberSwap, 1inch, etc.)"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Benefits of Zap Out:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Users can receive any ERC20 token as output from Pendle operations"}),"\n",(0,s.jsx)(n.li,{children:"No need to manually swap tokens after exiting Pendle positions"}),"\n",(0,s.jsx)(n.li,{children:"Optimal routing through multiple DEXes for best price execution"}),"\n",(0,s.jsx)(n.li,{children:"Single transaction for Pendle operation + swap"}),"\n",(0,s.jsxs)(n.li,{children:["Built-in slippage protection with ",(0,s.jsx)(n.code,{children:"minTokenOut"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"SDK Integration:"}),"\nThe ",(0,s.jsx)(n.a,{href:"/Developers/Backend/BackendAndHostedSDK#features",children:"Pendle Hosted SDK"})," automatically handles all TokenOutput configuration when you enable routing. When you set ",(0,s.jsx)(n.code,{children:"enableAggregator: true"})," in SDK calls, it:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Automatically selects the best swap aggregator for output token conversion"}),"\n",(0,s.jsxs)(n.li,{children:["Generates optimal ",(0,s.jsx)(n.code,{children:"swapData"})," for the chosen route"]}),"\n",(0,s.jsx)(n.li,{children:"Calculates appropriate slippage protection"}),"\n",(0,s.jsx)(n.li,{children:"Handles all token conversions transparently"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For direct contract interaction, you need to manually configure these fields or use utility functions like ",(0,s.jsx)(n.code,{children:"createTokenOutputSimple()"})," for basic operations."]}),"\n",(0,s.jsx)(n.h3,{id:"approxparams",children:"ApproxParams"}),"\n",(0,s.jsxs)(n.p,{children:["Parameters for approximation algorithms used when swapping exact tokens to PT or YT. ",(0,s.jsx)(n.strong,{children:"ApproxParams is required when the exact output amount needs to be determined through iterative approximation"})," because the Pendle AMM formula cannot be directly inverted."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"struct ApproxParams {\n    uint256 guessMin;\n    uint256 guessMax;\n    uint256 guessOffchain;\n    uint256 maxIteration;\n    uint256 eps;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fields"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"guessMin"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Minimum bound for binary search"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"guessMax"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsxs)(n.td,{children:["Maximum bound for binary search (use ",(0,s.jsx)(n.code,{children:"type(uint256).max"})," for auto)"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"guessOffchain"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsxs)(n.td,{children:["Initial guess from off-chain calculation (use ",(0,s.jsx)(n.code,{children:"0"})," for on-chain)"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"maxIteration"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsxs)(n.td,{children:["Maximum iterations for binary search (recommended: ",(0,s.jsx)(n.code,{children:"256"}),")"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"eps"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsxs)(n.td,{children:["Precision tolerance (recommended: ",(0,s.jsx)(n.code,{children:"1e14"}),")"]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When ApproxParams is Needed:"})}),"\n",(0,s.jsx)(n.p,{children:"ApproxParams is required for functions that swap an exact amount of tokens to PT or YT, such as:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/PtFunctions#swapexacttokenforpt",children:(0,s.jsx)(n.code,{children:"swapExactTokenForPt"})})," - Convert exact token amount to PT"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/PtFunctions#swapexactsyforpt",children:(0,s.jsx)(n.code,{children:"swapExactSyForPt"})})," - Convert exact SY amount to PT"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/YtFunctions#swapexacttokenforyt",children:(0,s.jsx)(n.code,{children:"swapExactTokenForYt"})})," - Convert exact token amount to YT"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/Developers/Contracts/PendleRouter/ApiReference/YtFunctions#swapexactsyforyt",children:(0,s.jsx)(n.code,{children:"swapExactSyForYt"})})," - Convert exact SY amount to YT"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Why Approximation is Required:"}),"\nThe Pendle AMM natively supports functions like ",(0,s.jsx)(n.code,{children:"swapExactPtForSy"})," and ",(0,s.jsx)(n.code,{children:"swapSyForExactPt"}),", but does NOT have ",(0,s.jsx)(n.code,{children:"swapExactSyForPt"}),". When you want to swap an exact amount of tokens/SY for PT/YT, the router must use binary search to determine how much PT/YT can be obtained, since the AMM can only calculate the reverse (exact PT amounts)."]}),"\n",(0,s.jsx)(n.h3,{id:"limitorderdata",children:"LimitOrderData"}),"\n",(0,s.jsxs)(n.p,{children:["Configuration for limit order functionality that ",(0,s.jsx)(n.strong,{children:"provides better prices and reduces slippage"})," by filling user orders at predetermined rates before routing to the AMM."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"struct LimitOrderData {\n    address limitRouter;\n    uint256 epsSkipMarket;\n    FillOrderParams[] normalFills;\n    FillOrderParams[] flashFills;\n    bytes optData;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fields"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"limitRouter"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address of limit order router"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"epsSkipMarket"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Threshold to skip market operations"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"normalFills"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"FillOrderParams[]"})}),(0,s.jsx)(n.td,{children:"Normal limit order fills"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"flashFills"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"FillOrderParams[]"})}),(0,s.jsx)(n.td,{children:"Flash loan limit order fills"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"optData"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"bytes"})}),(0,s.jsx)(n.td,{children:"Additional optimization data"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"redeemytincometotokenstruct",children:"RedeemYtIncomeToTokenStruct"}),"\n",(0,s.jsx)(n.p,{children:"Configuration for YT income redemption with token conversion."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"struct RedeemYtIncomeToTokenStruct {\n    IPYieldToken yt;\n    bool doRedeemInterest;\n    bool doRedeemRewards;\n    address tokenRedeemSy;\n    uint256 minTokenRedeemOut;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fields"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"yt"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"IPYieldToken"})}),(0,s.jsx)(n.td,{children:"YT token contract interface"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"doRedeemInterest"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"bool"})}),(0,s.jsx)(n.td,{children:"Whether to redeem accrued interest"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"doRedeemRewards"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"bool"})}),(0,s.jsx)(n.td,{children:"Whether to redeem reward tokens"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"tokenRedeemSy"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Token to convert SY interest to"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"minTokenRedeemOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Minimum tokens to receive from conversion"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"swapdata",children:"SwapData"}),"\n",(0,s.jsx)(n.p,{children:"Configuration for external swap aggregation functionality."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"struct SwapData {\n    SwapType swapType;\n    address extRouter;\n    bytes extCalldata;\n    bool needScale;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fields"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"swapType"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"SwapType"})}),(0,s.jsx)(n.td,{children:"Type of swap aggregator to use"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"extRouter"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address of the external swap router"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"extCalldata"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"bytes"})}),(0,s.jsx)(n.td,{children:"Encoded calldata for the external swap"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"needScale"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"bool"})}),(0,s.jsx)(n.td,{children:"Whether the swap amount needs scaling"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Case"}),"\nEnables integration with external swap aggregators like KyberSwap, 1inch, Paraswap, etc. This allows Pendle to support zapping in/out with any ERC20 token by routing through external DEXes."]}),"\n",(0,s.jsx)(n.h3,{id:"swaptype",children:"SwapType"}),"\n",(0,s.jsxs)(n.p,{children:["Enumeration defining supported swap aggregator types. See the ",(0,s.jsx)(n.a,{href:"https://github.com/pendle-finance/pendle-core-v2-public/blob/main/contracts/router/swap-aggregator/IPSwapAggregator.sol#L18-L31",children:"complete SwapType definition"})," in the smart contract."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"enum SwapType {\n    NONE,\n    KYBERSWAP,\n    ODOS,\n    ETH_WETH,\n    OKX,\n    ONE_INCH,\n    PARASWAP\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Value"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"NONE"})}),(0,s.jsx)(n.td,{children:"No external swap aggregation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"KYBERSWAP"})}),(0,s.jsx)(n.td,{children:"KyberSwap aggregation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ODOS"})}),(0,s.jsx)(n.td,{children:"ODOS aggregation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ETH_WETH"})}),(0,s.jsx)(n.td,{children:"ETH/WETH conversion"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"OKX"})}),(0,s.jsx)(n.td,{children:"OKX DEX aggregation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ONE_INCH"})}),(0,s.jsx)(n.td,{children:"1inch aggregation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PARASWAP"})}),(0,s.jsx)(n.td,{children:"Paraswap aggregation"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Case"}),"\nSpecifies which external aggregator to use for token swaps, enabling Pendle to leverage the best available liquidity across different DEXes. The ",(0,s.jsx)(n.a,{href:"/Developers/Backend/BackendAndHostedSDK#features",children:"Pendle Hosted SDK"})," automatically selects the optimal SwapType based on available liquidity and routing efficiency."]}),"\n",(0,s.jsx)(n.h3,{id:"exitpreexpreturnparams",children:"ExitPreExpReturnParams"}),"\n",(0,s.jsx)(n.p,{children:"Detailed breakdown of returns from pre-expiry position exit operations."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"struct ExitPreExpReturnParams {\n    uint256 netPtFromRemove;\n    uint256 netSyFromRemove;\n    uint256 netPyRedeem;\n    uint256 netSyFromRedeem;\n    uint256 netPtSwap;\n    uint256 netYtSwap;\n    uint256 netSyFromSwap;\n    uint256 netSyFee;\n    uint256 totalSyOut;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fields"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netPtFromRemove"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"PT tokens obtained from LP removal"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFromRemove"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"SY tokens obtained from LP removal"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netPyRedeem"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"PT+YT pairs redeemed to SY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFromRedeem"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"SY tokens from PT+YT redemption"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netPtSwap"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"PT tokens swapped to SY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netYtSwap"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"YT tokens swapped to SY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFromSwap"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"SY tokens from PT/YT swaps"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFee"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Trading fees paid in SY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"totalSyOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Total SY tokens received"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Case"}),"\nProvides detailed breakdown of complex exit operations before market expiry, helping users understand exactly how their positions were unwound and what fees were paid."]}),"\n",(0,s.jsx)(n.h3,{id:"exitpostexpreturnparams",children:"ExitPostExpReturnParams"}),"\n",(0,s.jsx)(n.p,{children:"Breakdown of returns from post-expiry position exit operations."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"struct ExitPostExpReturnParams {\n    uint256 netPtFromRemove;\n    uint256 netSyFromRemove;\n    uint256 netPtRedeem;\n    uint256 netSyFromRedeem;\n    uint256 totalSyOut;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fields"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netPtFromRemove"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"PT tokens obtained from LP removal"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFromRemove"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"SY tokens obtained from LP removal"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netPtRedeem"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"PT tokens redeemed at maturity"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netSyFromRedeem"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"SY tokens from PT redemption"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"totalSyOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Total SY tokens received"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Case"}),"\nProvides breakdown of exit operations after market expiry when PT tokens can be redeemed 1:1 for underlying assets. Simpler than pre-expiry exits since no swapping is required."]}),"\n",(0,s.jsx)(n.h2,{id:"utility-functions",children:"Utility Functions"}),"\n",(0,s.jsx)(n.p,{children:"These functions generate the parameters described above on-chain, offering an alternative for users who do not utilize the Pendle SDK."}),"\n",(0,s.jsx)(n.h3,{id:"createtokeninputsimple",children:"createTokenInputSimple"}),"\n",(0,s.jsx)(n.p,{children:"Creates a simple TokenInput struct without external swapping."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function createTokenInputSimple(address tokenIn, uint256 netTokenIn) pure returns (TokenInput memory)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"tokenIn"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Input token address (must be supported by target SY)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"netTokenIn"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Amount of input tokens"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"-"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"TokenInput"})}),(0,s.jsx)(n.td,{children:"Configured TokenInput struct"})]})})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Case"}),"\nMost common way to create TokenInput for standard operations. The tokenIn must be one of the tokens accepted by the target SY contract (check via ",(0,s.jsx)(n.code,{children:"IStandardizedYield.getTokensIn()"}),")."]}),"\n",(0,s.jsx)(n.h3,{id:"createtokenoutputsimple",children:"createTokenOutputSimple"}),"\n",(0,s.jsx)(n.p,{children:"Creates a simple TokenOutput struct without external swapping."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function createTokenOutputSimple(address tokenOut, uint256 minTokenOut) pure returns (TokenOutput memory)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"tokenOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Output token address (must be supported by target SY)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"minTokenOut"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"Minimum amount of output tokens"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"-"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"TokenOutput"})}),(0,s.jsx)(n.td,{children:"Configured TokenOutput struct"})]})})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Case"}),"\nMost common way to create TokenOutput for standard operations. The tokenOut must be one of the tokens that the target SY can redeem to (check via ",(0,s.jsx)(n.code,{children:"IStandardizedYield.getTokensOut()"}),")."]}),"\n",(0,s.jsx)(n.h3,{id:"createdefaultapproxparams",children:"createDefaultApproxParams"}),"\n",(0,s.jsx)(n.p,{children:"Creates default approximation parameters suitable for most operations."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function createDefaultApproxParams() pure returns (ApproxParams memory)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"-"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ApproxParams"})}),(0,s.jsx)(n.td,{children:"Configured ApproxParams with optimal defaults"})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Configuration"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["guessMin: ",(0,s.jsx)(n.code,{children:"0"})]}),"\n",(0,s.jsxs)(n.li,{children:["guessMax: ",(0,s.jsx)(n.code,{children:"type(uint256).max"})," (auto-detection)"]}),"\n",(0,s.jsxs)(n.li,{children:["guessOffchain: ",(0,s.jsx)(n.code,{children:"0"})," (pure on-chain calculation)"]}),"\n",(0,s.jsxs)(n.li,{children:["maxIteration: ",(0,s.jsx)(n.code,{children:"256"})," (sufficient for most cases)"]}),"\n",(0,s.jsxs)(n.li,{children:["eps: ",(0,s.jsx)(n.code,{children:"1e14"})," (0.01% precision)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Case"}),"\nRecommended for all operations requiring approximation. These parameters provide good balance between accuracy and gas costs."]}),"\n",(0,s.jsx)(n.h3,{id:"createemptylimitorderdata",children:"createEmptyLimitOrderData"}),"\n",(0,s.jsx)(n.p,{children:"Creates an empty LimitOrderData struct for operations without limit orders."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function createEmptyLimitOrderData() pure returns (LimitOrderData memory)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Return Values"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"-"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"LimitOrderData"})}),(0,s.jsx)(n.td,{children:"Empty LimitOrderData struct"})]})})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Case"}),"\nUse when you don't need limit order functionality. Required by many functions but can be empty for standard market operations."]}),"\n",(0,s.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,s.jsx)(n.h3,{id:"basic-parameter-creation",children:"Basic Parameter Creation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// Create input parameters for 1000 USDC\nTokenInput memory input = createTokenInputSimple(USDC_ADDRESS, 1000e6);\n\n// Create output parameters expecting at least 950 USDC\nTokenOutput memory output = createTokenOutputSimple(USDC_ADDRESS, 950e6);\n\n// Create default approximation parameters\nApproxParams memory approx = createDefaultApproxParams();\n\n// Create empty limit order data\nLimitOrderData memory limit = createEmptyLimitOrderData();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"complete-function-call-example",children:"Complete Function Call Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// Add liquidity with properly configured parameters\nrouter.addLiquiditySingleToken(\n    msg.sender,                                           // receiver\n    MARKET_ADDRESS,                                       // market\n    minLpOut,                                            // minLpOut\n    createDefaultApproxParams(),                         // guessPtReceivedFromSy\n    createTokenInputSimple(USDC_ADDRESS, 1000e6),        // input\n    createEmptyLimitOrderData()                          // limit\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"custom-approxparams-for-advanced-use",children:"Custom ApproxParams for Advanced Use"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// Create custom approximation parameters for high precision\nApproxParams memory customApprox = ApproxParams({\n    guessMin: 0,\n    guessMax: type(uint256).max,\n    guessOffchain: estimatedOutput,  // Use off-chain calculation if available\n    maxIteration: 512,               // Higher precision\n    eps: 1e15                        // Tighter tolerance (0.001%)\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"For Standard Operations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Always use ",(0,s.jsx)(n.code,{children:"createDefaultApproxParams()"})," unless you have specific precision requirements"]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"createEmptyLimitOrderData()"})," for simple market operations"]}),"\n",(0,s.jsx)(n.li,{children:"Ensure token addresses are supported by target SY contracts"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"For Performance:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Off-chain approximation (",(0,s.jsx)(n.code,{children:"guessOffchain"}),") can reduce gas costs significantly"]}),"\n",(0,s.jsxs)(n.li,{children:["Higher ",(0,s.jsx)(n.code,{children:"maxIteration"})," values increase precision but cost more gas"]}),"\n",(0,s.jsxs)(n.li,{children:["Tighter ",(0,s.jsx)(n.code,{children:"eps"})," values improve precision but may increase iterations"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}}}]);