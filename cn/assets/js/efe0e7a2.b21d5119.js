"use strict";(self.webpackChunkpendle_documentation=self.webpackChunkpendle_documentation||[]).push([[7132],{8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var r=n(6540);const i={},s=r.createContext(i);function a(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:t},e.children)}},9153:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Contracts/Market","title":"Market View Functions","description":"The Market contract provides comprehensive view functions for querying market state, user positions, order book data, and risk parameters.","source":"@site/docs/boros-dev-docs/Contracts/Market.mdx","sourceDirName":"Contracts","slug":"/Contracts/Market","permalink":"/cn/boros-dev/Contracts/Market","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"borosSidebar","previous":{"title":"\ud83c\udfea MarketHub","permalink":"/cn/boros-dev/Contracts/MarketHub"},"next":{"title":"\ud83c\udfa8 Custom Types","permalink":"/cn/boros-dev/Contracts/CustomTypes"}}');var i=n(4848),s=n(8453);const a={},o="Market View Functions",d={},c=[{value:"Market Information",id:"market-information",level:2},{value:"<code>descriptor()</code>",id:"descriptor",level:3},{value:"<code>name()</code> and <code>symbol()</code>",id:"name-and-symbol",level:3},{value:"<code>getOI()</code>",id:"getoi",level:3},{value:"<code>getMarketConfig()</code>",id:"getmarketconfig",level:3},{value:"Order Book",id:"order-book",level:2},{value:"<code>getNextNTicks()</code>",id:"getnextnticks",level:3},{value:"<code>getAllOpenOrders()</code>",id:"getallopenorders",level:3},{value:"<code>getOrder()</code>",id:"getorder",level:3},{value:"Position and Risk",id:"position-and-risk",level:2},{value:"<code>getSignedSizeNoSettle()</code>",id:"getsignedsizenosettle",level:3},{value:"<code>calcPositionValueNoSettle()</code>",id:"calcpositionvaluenosettle",level:3},{value:"<code>calcMarginNoSettle()</code>",id:"calcmarginnosettle",level:3},{value:"<code>getMarginFactor()</code>",id:"getmarginfactor",level:3},{value:"<code>getPendingSizes()</code>",id:"getpendingsizes",level:3},{value:"Funding and Settlement Tracking",id:"funding-and-settlement-tracking",level:2},{value:"<code>getLatestFIndex()</code>",id:"getlatestfindex",level:3},{value:"Rate Information",id:"rate-information",level:2},{value:"<code>getImpliedRate()</code>",id:"getimpliedrate",level:3},{value:"<code>getMarkRateView()</code>",id:"getmarkrateview",level:3},{value:"Fees",id:"fees",level:2},{value:"<code>getBestFeeRates()</code>",id:"getbestfeerates",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"market-view-functions",children:"Market View Functions"})}),"\n",(0,i.jsx)(t.p,{children:"The Market contract provides comprehensive view functions for querying market state, user positions, order book data, and risk parameters."}),"\n",(0,i.jsx)(t.h2,{id:"market-information",children:"Market Information"}),"\n",(0,i.jsx)(t.h3,{id:"descriptor",children:(0,i.jsx)(t.code,{children:"descriptor()"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"(\n    bool isIsolatedOnly,     // True if market only supports isolated margin\n    TokenId tokenId,         // Underlying collateral token ID\n    MarketId marketId,       // Unique market identifier\n    uint32 maturity,         // Maturity timestamp\n    uint8 tickStep,          // Tick step for calculating tick rate\n    uint16 iTickThresh,      // Tick threshold for margin calculation\n    uint32 latestFTime       // Latest fTime\n) = market.descriptor();\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The rate threshold for margin calculations can be derived from ",(0,i.jsx)(t.code,{children:"tickStep"})," and ",(0,i.jsx)(t.code,{children:"iTickThresh"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"int256 rateThreshold = TickMath.getRateAtTick(iTickThresh, tickStep);\n"})}),"\n",(0,i.jsxs)(t.h3,{id:"name-and-symbol",children:[(0,i.jsx)(t.code,{children:"name()"})," and ",(0,i.jsx)(t.code,{children:"symbol()"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:'string memory marketName = market.name();     // e.g., "Binance ETHUSDT 26 Sep 2025"\nstring memory marketSymbol = market.symbol(); // e.g., "BINANCE-ETHUSDT-26SEP2025"\n'})}),"\n",(0,i.jsx)(t.h3,{id:"getoi",children:(0,i.jsx)(t.code,{children:"getOI()"})}),"\n",(0,i.jsx)(t.p,{children:"Returns the total open interest across both long and short positions. Note that this represents the sum of absolute position sizes from both sides, which differs from conventional open interest calculations that typically report only one side."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:'uint256 openInterest = market.getOI();\nconsole.log("Total open interest: %s", openInterest);\n'})}),"\n",(0,i.jsx)(t.h3,{id:"getmarketconfig",children:(0,i.jsx)(t.code,{children:"getMarketConfig()"})}),"\n",(0,i.jsx)(t.p,{children:"Returns the complete market configuration parameters:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:'struct MarketConfigStruct {\n    uint16 maxOpenOrders;                    // Maximum orders per account\n    address markRateOracle;                  // Oracle for mark rate calculation\n    address fIndexOracle;                    // Oracle for floating index updates\n    uint128 hardOICap;                       // Hard open interest cap\n    uint64 takerFee;                         // Taker fee rate\n    uint64 otcFee;                           // OTC swap fee rate\n    LiqSettings liqSettings;                 // Liquidation incentive parameters\n    uint64 kIM;                              // Initial margin factor\n    uint64 kMM;                              // Maintenance margin factor\n    uint32 tThresh;                          // Time threshold for margin calculations\n    uint16 maxRateDeviationFactorBase1e4;    // Max rate deviation from mark rate\n    uint16 closingOrderBoundBase1e4;         // Rate bounds for closing orders\n    int16 loUpperConstBase1e4;               // Limit order upper constant\n    int16 loUpperSlopeBase1e4;               // Limit order upper slope\n    int16 loLowerConstBase1e4;               // Limit order lower constant\n    int16 loLowerSlopeBase1e4;               // Limit order lower slope\n    MarketStatus status;                     // Market status (PAUSED/CLO/GOOD)\n    bool useImpliedAsMarkRate;               // Whether to use implied rate as mark rate\n}\n\nMarketConfigStruct memory config = market.getMarketConfig();\nconsole.log("Max open orders: %s", config.maxOpenOrders);\nconsole.log("Taker fee: %s bps", config.takerFee);\n'})}),"\n",(0,i.jsx)(t.h2,{id:"order-book",children:"Order Book"}),"\n",(0,i.jsx)(t.h3,{id:"getnextnticks",children:(0,i.jsx)(t.code,{children:"getNextNTicks()"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"// Get best 10 LONG ticks\n(int16[] memory ticks, uint256[] memory sizes) = market.getNextNTicks(\n    Side.LONG,\n    Side.LONG.tickToGetFirstAvail(),\n    10\n);\n\n// Get liquidity after specific tick\nint16 bestAskTick = 125;\n(int16[] memory nextTicks, uint256[] memory nextSizes) = market.getNextNTicks(\n    Side.SHORT,\n    bestAskTick,   // Start after this tick\n    5\n);\n"})}),"\n",(0,i.jsx)(t.h3,{id:"getallopenorders",children:(0,i.jsx)(t.code,{children:"getAllOpenOrders()"})}),"\n",(0,i.jsx)(t.p,{children:"Returns all open orders for a user account. Each order contains:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"struct Order {\n    OrderStatus status;  // NOT_EXIST, OPEN, PENDING_SETTLE, PURGED\n    OrderId id;          // Unique 64-bit identifier encoding side, tick, and index\n    MarketAcc maker;     // Account that placed the order\n    uint256 size;        // Order size (18 decimals)\n    int256 rate;         // Order rate derived from tick index\n}\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:'MarketAcc userAccount = AccountLib.toMainCross(userAddress, tokenId);\nOrder[] memory orders = market.getAllOpenOrders(userAccount);\n\nfor (uint i = 0; i < orders.length; i++) {\n    Order memory order = orders[i];\n    console.log("Order ID: %s", OrderId.unwrap(order.id));\n    console.log("Size: %s", order.size);\n    console.log("Rate: %s", order.rate);\n    console.log("Status: %s", uint(order.status));\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"getorder",children:(0,i.jsx)(t.code,{children:"getOrder()"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"OrderId orderId = OrderIdLib.from(Side.LONG, 125, 1000);\nOrder memory order = market.getOrder(orderId);\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Caveats:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["For order that is ",(0,i.jsx)(t.strong,{children:"not fully filled"}),", ",(0,i.jsx)(t.code,{children:"size"})," returns the ",(0,i.jsx)(t.strong,{children:"remaining unfilled size"}),", not the original order size."]}),"\n",(0,i.jsxs)(t.li,{children:["If an order is partially filled (possible multiple times) before being fully filled, ",(0,i.jsx)(t.code,{children:"size"})," returns the remaining order size right before the order gets fully filled, excluding previous partial fills."]}),"\n",(0,i.jsxs)(t.li,{children:["Cancelled orders show ",(0,i.jsx)(t.code,{children:"status = NOT_EXIST"})," and ",(0,i.jsx)(t.code,{children:"size = 0"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"position-and-risk",children:"Position and Risk"}),"\n",(0,i.jsxs)(t.p,{children:["Functions ending with ",(0,i.jsx)(t.code,{children:"NoSettle"})," return potentially outdated data without triggering settlement. Due to Boros's lazy settlement system, on-chain state may not reflect the latest position values until the next user interaction."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Important:"})," For accurate, up-to-date position data, first trigger ",(0,i.jsx)(t.a,{href:"/cn/boros-dev/Mechanics/Settlement",children:"settlement"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"IMarketHub(marketHub).settleAllAndGet(userAccount, GetRequest.ZERO, MarketId.ZERO);\n"})}),"\n",(0,i.jsx)(t.h3,{id:"getsignedsizenosettle",children:(0,i.jsx)(t.code,{children:"getSignedSizeNoSettle()"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"MarketAcc userAccount = AccountLib.toCross(mainAccount, tokenId);\nint256 position = market.getSignedSizeNoSettle(userAccount);\n"})}),"\n",(0,i.jsx)(t.h3,{id:"calcpositionvaluenosettle",children:(0,i.jsx)(t.code,{children:"calcPositionValueNoSettle()"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"int256 positionValue = market.calcPositionValueNoSettle(userAccount);\n"})}),"\n",(0,i.jsx)(t.h3,{id:"calcmarginnosettle",children:(0,i.jsx)(t.code,{children:"calcMarginNoSettle()"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"// Calculate initial margin requirement\nuint256 initialMargin = market.calcMarginNoSettle(userAccount, MarginType.IM);\n\n// Calculate maintenance margin requirement\nuint256 maintenanceMargin = market.calcMarginNoSettle(userAccount, MarginType.MM);\n"})}),"\n",(0,i.jsx)(t.h3,{id:"getmarginfactor",children:(0,i.jsx)(t.code,{children:"getMarginFactor()"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"(uint64 kIM, uint64 kMM) = market.getMarginFactor(userAccount);\n"})}),"\n",(0,i.jsx)(t.h3,{id:"getpendingsizes",children:(0,i.jsx)(t.code,{children:"getPendingSizes()"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:'(uint256 pendingLong, uint256 pendingShort) = market.getPendingSizes(userAccount);\nconsole.log("Pending long orders: %s", pendingLong);\nconsole.log("Pending short orders: %s", pendingShort);\n'})}),"\n",(0,i.jsx)(t.h2,{id:"funding-and-settlement-tracking",children:"Funding and Settlement Tracking"}),"\n",(0,i.jsx)(t.h3,{id:"getlatestfindex",children:(0,i.jsx)(t.code,{children:"getLatestFIndex()"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"FIndex latestIndex = market.getLatestFIndex();\n\nuint32 fTime = latestIndex.fTime();\nint112 floatingIndex = latestIndex.floatingIndex();\nuint64 feeIndex = latestIndex.feeIndex();\n"})}),"\n",(0,i.jsx)(t.h2,{id:"rate-information",children:"Rate Information"}),"\n",(0,i.jsx)(t.h3,{id:"getimpliedrate",children:(0,i.jsx)(t.code,{children:"getImpliedRate()"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"(\n    int128 lastTradedRate,      // Last trade execution rate\n    int128 oracleRate,          // TWAP rate\n    uint32 lastTradedTime,      // Timestamp of last trade\n    uint32 observationWindow    // Rate observation window\n) = market.getImpliedRate();\n"})}),"\n",(0,i.jsx)(t.h3,{id:"getmarkrateview",children:(0,i.jsx)(t.code,{children:"getMarkRateView()"})}),"\n",(0,i.jsx)(t.p,{children:"Returns the current mark rate used for margin calculations and position valuation. This is the oracle-based TWAP rate from the order book's rate observations."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"int256 markRate = market.getMarkRateView();\n"})}),"\n",(0,i.jsx)(t.h2,{id:"fees",children:"Fees"}),"\n",(0,i.jsx)(t.h3,{id:"getbestfeerates",children:(0,i.jsx)(t.code,{children:"getBestFeeRates()"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"MarketAcc user = AccountLib.toMainCross(userAddress, tokenId);\nMarketAcc counterparty = AccountLib.toMainCross(counterpartyAddress, tokenId);\n\n(uint64 takerFee, uint64 otcFee) = market.getBestFeeRates(user, counterparty);\n"})})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);